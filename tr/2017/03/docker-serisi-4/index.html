<!doctype html><html lang=tr dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Docker Serisi #4 -- Docker Compose | Alper Kanat</title><meta name=keywords content="yazılım,docker,docker serisi,container,sanallaştırma,linux,devops"><meta name=description content="bölüme hoşgeldiniz! 🤘🏻 Serinin önceki bölümlerine ulaşmak için aşağıdaki bağlantıları kullanabilirsiniz: Docker Serisi #1 Docker Serisi #2 — Docker Engine Bölüm 1 Docker Serisi #3 — Docker Engine Bölüm 2 Daha çok geliştirme üstüne duracak olsam da, Docker Compose’u test ortamı ya da farklı ihtiyaçlar için de kullanabilirsiniz. Özellikle tek bir makine üstünde birden fazla container ile çalışmayı düşünüyorsanız Docker Compose mutlaka incelemeniz gereken bir araç!
Güncelleme: Docker 1.13 ile birlikte Docker Compose ile tanımladığınız bir projeyi Swarm ile birden çok makineye dağıtabiliyorsunuz!"><meta name=author content><link rel=canonical href=https://alperkan.at/tr/2017/03/docker-serisi-4/><link crossorigin=anonymous href=/assets/css/stylesheet.min.2d6dbfc6e0f8a1db1c9d082a76dc11d094328cf63f247bbc2421dfaa7f2bb170.css integrity="sha256-LW2/xuD4odscnQgqdtwR0JQyjPY/JHu8JCHfqn8rsXA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://alperkan.at/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://alperkan.at/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://alperkan.at/favicon-32x32.png><link rel=apple-touch-icon href=https://alperkan.at/apple-touch-icon.png><link rel=mask-icon href=https://alperkan.at/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.102.3"><link rel=alternate hreflang=tr href=https://alperkan.at/tr/2017/03/docker-serisi-4/><script async src="https://www.googletagmanager.com/gtag/js?id=G-SDT9Y68PM3"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-SDT9Y68PM3",{anonymize_ip:!1})}</script><meta property="og:title" content="Docker Serisi #4 -- Docker Compose"><meta property="og:description" content="bölüme hoşgeldiniz! 🤘🏻 Serinin önceki bölümlerine ulaşmak için aşağıdaki bağlantıları kullanabilirsiniz: Docker Serisi #1 Docker Serisi #2 — Docker Engine Bölüm 1 Docker Serisi #3 — Docker Engine Bölüm 2 Daha çok geliştirme üstüne duracak olsam da, Docker Compose’u test ortamı ya da farklı ihtiyaçlar için de kullanabilirsiniz. Özellikle tek bir makine üstünde birden fazla container ile çalışmayı düşünüyorsanız Docker Compose mutlaka incelemeniz gereken bir araç!
Güncelleme: Docker 1.13 ile birlikte Docker Compose ile tanımladığınız bir projeyi Swarm ile birden çok makineye dağıtabiliyorsunuz!"><meta property="og:type" content="article"><meta property="og:url" content="https://alperkan.at/tr/2017/03/docker-serisi-4/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-03-20T00:00:00+00:00"><meta property="article:modified_time" content="2021-04-26T00:02:59+03:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Docker Serisi #4 -- Docker Compose"><meta name=twitter:description content="bölüme hoşgeldiniz! 🤘🏻 Serinin önceki bölümlerine ulaşmak için aşağıdaki bağlantıları kullanabilirsiniz: Docker Serisi #1 Docker Serisi #2 — Docker Engine Bölüm 1 Docker Serisi #3 — Docker Engine Bölüm 2 Daha çok geliştirme üstüne duracak olsam da, Docker Compose’u test ortamı ya da farklı ihtiyaçlar için de kullanabilirsiniz. Özellikle tek bir makine üstünde birden fazla container ile çalışmayı düşünüyorsanız Docker Compose mutlaka incelemeniz gereken bir araç!
Güncelleme: Docker 1.13 ile birlikte Docker Compose ile tanımladığınız bir projeyi Swarm ile birden çok makineye dağıtabiliyorsunuz!"><script type=application/ld+json>
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://alperkan.at/tr/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Docker Serisi #4 -- Docker Compose",
      "item": "https://alperkan.at/tr/2017/03/docker-serisi-4/"
    }
  ]
}
</script><script type=application/ld+json>
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Docker Serisi #4 -- Docker Compose",
  "name": "Docker Serisi #4 -- Docker Compose",
  "description": "bölüme hoşgeldiniz! 🤘🏻 Serinin önceki bölümlerine ulaşmak için aşağıdaki bağlantıları kullanabilirsiniz: Docker Serisi #1 Docker Serisi #2 — Docker Engine Bölüm 1 Docker Serisi #3 — Docker Engine Bölüm 2 Daha çok geliştirme üstüne duracak olsam da, Docker Compose’u test ortamı ya da farklı ihtiyaçlar için de kullanabilirsiniz. Özellikle tek bir makine üstünde birden fazla container ile çalışmayı düşünüyorsanız Docker Compose mutlaka incelemeniz gereken bir araç!\nGüncelleme: Docker 1.13 ile birlikte Docker Compose ile tanımladığınız bir projeyi Swarm ile birden çok makineye dağıtabiliyorsunuz!",
  "keywords": [
    "yazılım", "docker", "docker serisi", "container", "sanallaştırma", "linux", "devops"
  ],
  "articleBody": " bölüme hoşgeldiniz! 🤘🏻 Serinin önceki bölümlerine ulaşmak için aşağıdaki bağlantıları kullanabilirsiniz: Docker Serisi #1 Docker Serisi #2 — Docker Engine Bölüm 1 Docker Serisi #3 — Docker Engine Bölüm 2 Daha çok geliştirme üstüne duracak olsam da, Docker Compose’u test ortamı ya da farklı ihtiyaçlar için de kullanabilirsiniz. Özellikle tek bir makine üstünde birden fazla container ile çalışmayı düşünüyorsanız Docker Compose mutlaka incelemeniz gereken bir araç!\nGüncelleme: Docker 1.13 ile birlikte Docker Compose ile tanımladığınız bir projeyi Swarm ile birden çok makineye dağıtabiliyorsunuz! 🎉 Seride buna da yer vermek farz oldu tabii ki!\nÖzetle; uygulamanızı, projenize yerleştireceğiniz docker-compose.yml adında bir dosya aracılığıyla servisler olarak tanımlamanıza olanak tanır ve çalıştırdığınızda ilgili container’ları, disk bölümlerini, ağları vb. her şeyi oluşturup işiniz bittiğinde de tamamen kaldırır. O zaman kurulum ile hemen işe koyulalım! 😊\nKurulum Kurulum için şuradaki dökümanı takip edebilirsiniz. macOS ve brew kullanıyorsanız;\nbrew install docker-compose komutuyla kurulumu tamamlayabilirsiniz. Eğer makinenizde Python (pip \u003e= 6.0) kullanıyorsanız;\npip install docker-compose komutunu kullanabilirsiniz. Alternatif olarak aşağıdaki komutlar ile de kurulumu gerçekleştirebilirsiniz:\n# curl -L https://github.com/docker/compose/releases/download/1.9.0/docker-compose-`uname -s`-`uname -m` \u003e /usr/local/bin/docker-compose # chmod +x /usr/local/bin/docker-compose Kurulumu başarıyla tamamladıysanız aşağıdaki gibi sürüm numarası çıktısını görebilmelisiniz:\n$ docker-compose --version docker-compose version 1.11.2, build dfed245 Yazının bundan sonraki bölümünde şu adreste bulabileceğiniz örnek projeyi kullanarak devam edeceğim. Dilerseniz indirip benimle beraber adımları tekrarlayabilir ve denemeler yapabilirsiniz.\ndocker-compose.yml Normalde projenizin ana dizinine tek bir docker-compose.yml dosyası koymak yeterli olmakla beraber, bir dizin birden fazla alt projeye ev sahipliği yapıyorsa bu durumda alt dizinlere de birer tane docker-compose.yml dosyası yerleştirebilirsiniz. Bu durumda -f parametresiyle dosya yolunu belirtmelisiniz.\nDosyanın biçimi, kullanılabilecek anahtar kelimeler vb. için şuradaki belgeyi inceleyebilirsiniz. Klasik bir docker-compose.yml dosyası yaklaşık olarak aşağıdaki gibidir:\nYML dosyası yazarken, bu dosya biçimine has yazım kurallarına dikkat etmelisiniz. Kapsamı iyice genişletmemek adına yazım kurallarına girmeyeceğim ancak özellikle girintilemeye özen göstermelisiniz.\nİlk satır dosyanın biçimlendirmesinde kullanılan tanımlamaların (spec) sürümünü belirtiyor ve ilk satırda olma zorunluluğu var. Docker 1.13 öncesinde sürüm numarası olarak yalnızca “2” kullanılırken, artık “3” de kullanılabiliyor. Sürüm numarası, dosyanın biçiminde yapılabilecek değişikliklerden etkilenilmemesi için düşünülmüş bir özellik. Yani eski bir projenizde sürüm olarak “2” kullanıyorsanız, artık desteklenmeyen bir Docker sürümü kullanmıyorsanız, projeniz olduğu gibi çalışacaktır. Yeni bir projeye başladığınızda sürümü “3” olarak belirtmeli ve yazım kurallarını da bu sürüme uyacak şekilde uygulamalısınız.\nDosyada tanımlamanız gereken ikinci kısım: servisler. Her bir servisi, ayrı birer container gibi düşünebilirsiniz. “services” kelimesinin altında, 1 girintileme ile ayırdığınız her şey bir servistir ve çalışacak container’ın adı burada yazdığınız kelimeyle anılacaktır.\nİlk servisimiz adından da anlaşılabileceği gibi API hizmeti sunan bir container’dan ibaret. Aynı servisten birden çok kez başlatma ihtimaline karşılık Compose, yazdığınız ismi, YML dosyasının bulunduğu dizin adı ve bir rakamla harmanlayıp container adı (ör: dockercomposedemo_api_1) yaratır. Yalnızca tek bir container başlatacağınızdan eminseniz servis tanımlarına\ncontainer_name: demo-api yazarak bu isimle açılmasını sağlayabilirsiniz. Bu durumda birden fazla container başlatmaya çalışırsanız hata alırsınız.\nServisimizin adının altında bir kez daha girintileme ile yazdığımız her şey servisi tanımlayan ayarlar olarak algılanır. Şimdi gelin; sırasıyla yazdıklarımızı anlamaya çalışalım:\nbuild: . Kısaca imajı oluşturulacak Dockerfile dosyasının yerini (build context) belirtmek için kullanılır. Bizim projemizde Dockerfile, YML dosyasıyla aynı dizinde bulunduğu için “.” (nokta) ile bu dizini işaret ediyoruz. Dilerseniz farklı bir dizindeki Dockerfile’ı işaret edebilir, Dockerfile yerine farklı bir isim kullanıyorsanız ya da imajı yaratabilmek için ek parametrelere ihtiyaç duyuyorsanız bunları da bu kısımda belirtebilirsiniz. Detaylar için tık tık.\nSwarm modunda bu parametre gözardı edilmekte ve bir alttaki image parametresi kullanılmaktadır.\nimage: tunix/docker-compose-demo İmajın derlenmesi sonucunda çıkacak Docker imajının adını bu komutla belirtiyoruz. Hiç bir şey yazmazsanız yine bulunduğunuz dizin ve verdiğiniz servis adını harmanlayarak bir isim (ör: dockercomposedemo_api) oluşturulacaktır.\nports YML dosya biçiminde “-” ile başlayan kısımlar üstündeki satırı dizi (array) olarak tanımlar. Yani birden fazla “-” ile başlayan satır yazarak, ports dizisine birden çok erişim noktası (port) ekleyebilirsiniz. Bizim örneğimiz için konuşursak; ev sahibi (host) makinedeki 8080. erişim noktasını, container içerisindeki 8080 numaralı erişim noktasına bağlıyoruz.\nBir erişim noktası, ev sahibi makinede yalnızca 1 kez kullanılabilir. Bu nedenle herhangi bir servisi, aynı ev sahibi makinede birden fazla kez çalıştırmayı düşünüyorsanız bu kısımda yalnızca container’a ait olan erişim noktasını belirtmelisiniz. Bu durumda, Compose container’ınıza ev sahibi makineden rastgele bir erişim noktası atar.\nlinks Altındaki tanımdan anlayacağınız üzere, “links” de bir dizi olup birden çok tanımlama kabul edebilir. Bir container, diğerine erişeceğinde bunun en kolay yolu bu container’ları birbirine bağlamaktır. Yazım şekline bakarsak “:” karakterinin solundaki servis adı, sağındakiyse takma addır. Container içinden veritabanına ulaşacağımızda bu takma adı kullanıyor olacağız. Bu, bizi gereksiz yere IP tanımlamaktan kurtacaktır. Proje içerisindeki application.yml dosyasına bakarsanız MySQL için kullandığımız bağlantı cümlesinde (connection string) takma ad olan demodb kelimesini kullandığımızı görebilirsiniz. Takma ad kullanmanın avantajı; servis adı değişse bile takma adın değişmemesidir. Böylece kodumuzda değişiklik yapmak zorunda kalmıyoruz.\nSwarm modunda bu parametre gözardı edilmektedir.\ncommand Container başlatılırken çalıştırılacak komutun ne olacağını belirler.\nSerinin önceki yazılarında bahsettiğim gibi, bu tanım aslında Dockerfile içinde de yapılabiliyor. Burada tekrar yapma sebebim, Compose’un yapısından kaynaklanıyor. Tahmin edebileceğiniz gibi MySQL başlayana kadar DB container’ındaki 3306 erişim noktası açık değil. Bu durumda uygulamam ayağa kalkarken bağlanamayıp hata verecektir. Bunu engellemek için erişim noktasını sürekli yoklayıp açılınca uygulamayı başlatan wait-for-it.sh adında bir betik (script) kullanıyorum.\nenvironment İmaj içerisinde tanımlı olan çevresel değişkenleri, yeni bir container başlatırken bu şekilde değiştirebiliyor, tanımlayabiliyorsunuz. DB servisi için belirttiğim değişkenler, container ayağa kalktığında çalışan betiğin, benim istediğim isimle bir veritabanı yaratmasını ve yine istediğim kullanıcı adı ve şifreyle çalışmasını sağlıyor.\nYalnızca 20 satırlık bu docker-compose.yml dosyasıyla API container’ının imajının yaratılmasını, ondan da bir container ayağa kaldırılmasını ve MySQL imajından DB adında bir container yaratılmasını sağlayabiliyorsunuz. Tabii ki yapabilecekleriniz bunlarla sınırlı değil. Ekleyebileceğiniz diğer parametrelerle container kayıtlarının nereye yazılacağını, container yükleme (deployment) stratejilerinin belirlenmesini, bağlanacak dosya/dizinleri ve daha pek çok ayarı yapabilirsiniz.\nSerinin ilerleyen bölümlerinde farklı proje örneklerinde Compose’u nasıl kullanabileceğinizi işliyor olacağım.\nCompose ile Çalışmak YML dosyasını inceledikten sonra sıra geldi container’larımızı çalıştırmaya! Bunun için YML dosyasının bulunduğu dizine gidin ve şu komutu çalıştırın:\ndocker-compose up -d Bu komut container’ları yaratacak, servisleri başlatacak ve sonrasında da çıkış yapacak. -d ya da uzun haliyle --daemon parametresi, komutun arka planda (daemon) çalışmasını sağlar. Çalıştıklarını da teyid edelim:\ndocker-compose ps\nDikkat ederseniz API servisimizin erişim noktası (8080) dışarıya açık ve erişilebilir durumdayken, DB servisimiz için aynı durum geçerli değil. Bunun sebebi, Compose’un YML dosyasında bu erişim noktasını açmamış olmamızdan kaynaklanıyor. Eğer veritabanınıza dışarıdan erişebilmek isterseniz dosyayı değiştirip erişim noktasını açmalı ve servisleri yeniden ayağa kaldırmalısınız.\nErişim noktası açık olmamasına rağmen, API servisi veritabanına bağlanabiliyor çünkü Compose container’ların kendi arasında iletişimi için özel bir ağ yarattı ve yukarıda bahsettiğim gibi, DB servisinin IP adresi demodb adıyla API servisine ait container tarafından ulaşılabilir durumda.\nCompose’un yarattığı bu ağ, servislerin izolasyonu açısından oldukça önemli. Serinin ilerleyen bölümlerinde göreceğimiz üzere, YML dosyasında yapacağınız bir takım değişikliklerle birden çok Compose YML dosyasıyla yönettiğiniz servisleri aynı ağa bağlamanız mümkün.\nArtık servisimiz ayakta olduğuna göre istek atıp üstünde çalışabiliriz:\nSpring Boot ile yazılmış HATEOAS REST API, DB’den aldığı sonuçları dönüyor.\ndocker-compose down komutunu vererek tüm servislerin kapatılmasını ve bunlara bağlı olarak yaratılmış ağ ile tüm container’ların silinmesini sağlayabilirsiniz:\ndocker-compose down komut çıktısı\nKolaylık olması açısından oluşturulan imajlar silinmiyor. Bu sayede bir sonraki sefer docker-compose up -d komutunu verdiğinizde servisleriniz çok daha hızlı ayağa kaldırılır. Eğer imajları da silmek isterseniz;\ndocker-compose down --rmi all komutunu verebilirsiniz.\nİpucu #1 Diyelim ki; Ubuntu bazlı bir Docker imajınız var ve her ayağa kalkışında aşağıdaki komutları çalıştırıyor:\napt-get update apt-get upgrade Daha farklı bir senaryo olarak, container’ınız ayağa kalkarken bir betik çalıştırarak git deponuzdaki kodun son halini de alıyor olabilir örneğin. Bu gibi senaryolarda down komutuyla her şeyi kaldırmak yerine;\ndocker-compose stop komutuyla ağı ve tüm servisleri geçici olarak pasifize edebilir, ihtiyacınız olduğunda da;\ndocker-compose start komutuyla yeniden başlatabilirsiniz.\nİpucu #2 Klasik Docker komutlarından farklı olarak Compose da logs, restart, rm, exec vb. pek çok komutu sağlıyor. Bunların amaçlarını ve kullanım şekillerini örneğin;\ndocker-compose logs --help komutuyla görüntüleyebilirsiniz.\nİpucu #3 Yukarıdaki örnekte bir API servisi, bir de DB servisi çalıştırmıştık. Aşağıdaki komutla istediğiniz servisten, istediğiniz adette başlatabilirsiniz:\ndocker-compose scale api=2 db=1 Tabii uygulamanızın da buna hazır olması kaydıyla! 😉\nBu bölümünün de sonuna geldik. Bir sonraki bölümde Docker Machine ve Docker Swarm’dan bahsedeceğim.\nGidişâta göre bu planda zaman zaman değişiklikler yapacak olsam da serinin tüm bölümlerinin planına şuradan ulaşabilirsiniz.\n",
  "wordCount" : "1346",
  "inLanguage": "tr",
  "datePublished": "2017-03-20T00:00:00Z",
  "dateModified": "2021-04-26T00:02:59+03:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://alperkan.at/tr/2017/03/docker-serisi-4/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Alper Kanat",
    "logo": {
      "@type": "ImageObject",
      "url": "https://alperkan.at/favicon.ico"
    }
  }
}
</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://alperkan.at/tr/ accesskey=h title="Alper Kanat (Alt + H)">Alper Kanat</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://alperkan.at/ title=🇬🇧 aria-label=🇬🇧>En</a></li></ul></span></div><ul id=menu><li><a href=https://alperkan.at/tr/arsiv title=arşiv><span>arşiv</span></a></li><li><a href=https://alperkan.at/tr/tags title=etiketler><span>etiketler</span></a></li><li><a href=https://alperkan.at/tr/hakkimda title=hakkımda><span>hakkımda</span></a></li><li><a href=https://github.com/tunix/notebook title=notlarım><span>notlarım</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Docker Serisi #4 -- Docker Compose</h1><div class=post-meta>March 20, 2017</div></header><div class=post-content><ol start=4><li>bölüme hoşgeldiniz! 🤘🏻 Serinin önceki bölümlerine ulaşmak için aşağıdaki bağlantıları kullanabilirsiniz:</li></ol><ul><li><a href=https://alperkan.at/tr/2016/07/docker-serisi-1/>Docker Serisi #1</a></li><li><a href=https://alperkan.at/tr/2016/09/docker-serisi-2/>Docker Serisi #2 — Docker Engine Bölüm 1</a></li><li><a href=https://alperkan.at/tr/2016/10/docker-serisi-3/>Docker Serisi #3 — Docker Engine Bölüm 2</a></li></ul><p>Daha çok geliştirme üstüne duracak olsam da, <a href=https://docs.docker.com/compose/>Docker Compose</a>’u test ortamı ya da
farklı ihtiyaçlar için de kullanabilirsiniz. Özellikle tek bir makine üstünde birden fazla container ile çalışmayı
düşünüyorsanız <a href=https://docs.docker.com/compose/>Docker Compose</a> mutlaka incelemeniz gereken bir araç!</p><p><strong>Güncelleme:</strong> Docker 1.13 ile birlikte Docker Compose ile tanımladığınız bir projeyi
<a href=https://docs.docker.com/swarm/>Swarm</a> ile birden çok makineye dağıtabiliyorsunuz! 🎉 Seride buna da yer vermek farz
oldu tabii ki!</p><p>Özetle; uygulamanızı, projenize yerleştireceğiniz <code>docker-compose.yml</code> adında bir dosya aracılığıyla servisler olarak
tanımlamanıza olanak tanır ve çalıştırdığınızda ilgili container’ları, disk bölümlerini, ağları vb. her şeyi oluşturup
işiniz bittiğinde de tamamen kaldırır. O zaman kurulum ile hemen işe koyulalım! 😊</p><hr><h3 id=kurulum>Kurulum<a hidden class=anchor aria-hidden=true href=#kurulum>#</a></h3><p>Kurulum için <a href=https://docs.docker.com/compose/install/>şuradaki</a> dökümanı takip edebilirsiniz. macOS ve brew
kullanıyorsanız;</p><pre tabindex=0><code>brew install docker-compose
</code></pre><p>komutuyla kurulumu tamamlayabilirsiniz. Eğer makinenizde Python (pip >= 6.0) kullanıyorsanız;</p><pre tabindex=0><code>pip install docker-compose
</code></pre><p>komutunu kullanabilirsiniz. Alternatif olarak aşağıdaki komutlar ile de kurulumu gerçekleştirebilirsiniz:</p><pre tabindex=0><code># curl -L https://github.com/docker/compose/releases/download/1.9.0/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose
# chmod +x /usr/local/bin/docker-compose
</code></pre><p>Kurulumu başarıyla tamamladıysanız aşağıdaki gibi sürüm numarası çıktısını görebilmelisiniz:</p><pre tabindex=0><code>$ docker-compose --version
docker-compose version 1.11.2, build dfed245
</code></pre><hr><blockquote><p>Yazının bundan sonraki bölümünde <a href=https://github.com/tunix/docker-compose-demo>şu adreste</a> bulabileceğiniz örnek
projeyi kullanarak devam edeceğim. Dilerseniz indirip benimle beraber adımları tekrarlayabilir ve denemeler
yapabilirsiniz.</p></blockquote><hr><h3 id=docker-composeyml>docker-compose.yml<a hidden class=anchor aria-hidden=true href=#docker-composeyml>#</a></h3><p>Normalde projenizin ana dizinine tek bir <code>docker-compose.yml</code> dosyası koymak yeterli olmakla beraber, bir dizin birden
fazla alt projeye ev sahipliği yapıyorsa bu durumda alt dizinlere de birer tane <code>docker-compose.yml</code> dosyası
yerleştirebilirsiniz. Bu durumda <code>-f</code> parametresiyle dosya yolunu belirtmelisiniz.</p><p>Dosyanın biçimi, kullanılabilecek anahtar kelimeler vb. için <a href=https://docs.docker.com/compose/compose-file/>şuradaki</a>
belgeyi inceleyebilirsiniz. Klasik bir <code>docker-compose.yml</code> dosyası yaklaşık olarak aşağıdaki gibidir:</p><script type=application/javascript src=https://gist.github.com/tunix/15a0a926b3a16c6acb8ffbd75351fbf0.js></script><p>YML dosyası yazarken, bu dosya biçimine has yazım kurallarına dikkat etmelisiniz. Kapsamı iyice genişletmemek adına
yazım kurallarına girmeyeceğim ancak özellikle girintilemeye özen göstermelisiniz.</p><p>İlk satır dosyanın biçimlendirmesinde kullanılan tanımlamaların (spec) sürümünü belirtiyor ve ilk satırda olma
zorunluluğu var. Docker 1.13 öncesinde sürüm numarası olarak yalnızca &ldquo;2&rdquo; kullanılırken, artık &ldquo;3&rdquo; de kullanılabiliyor.
Sürüm numarası, dosyanın biçiminde yapılabilecek değişikliklerden etkilenilmemesi için düşünülmüş bir özellik. Yani
eski bir projenizde sürüm olarak &ldquo;2&rdquo; kullanıyorsanız, artık desteklenmeyen bir Docker sürümü kullanmıyorsanız, projeniz
olduğu gibi çalışacaktır. Yeni bir projeye başladığınızda sürümü &ldquo;3&rdquo; olarak belirtmeli ve yazım kurallarını da bu
sürüme uyacak şekilde uygulamalısınız.</p><p>Dosyada tanımlamanız gereken ikinci kısım: servisler. Her bir servisi, ayrı birer container gibi düşünebilirsiniz.
&ldquo;services&rdquo; kelimesinin altında, 1 girintileme ile ayırdığınız her şey bir servistir ve çalışacak container&rsquo;ın adı
burada yazdığınız kelimeyle anılacaktır.</p><p>İlk servisimiz adından da anlaşılabileceği gibi API hizmeti sunan bir container’dan ibaret. Aynı servisten birden çok
kez başlatma ihtimaline karşılık Compose, yazdığınız ismi, YML dosyasının bulunduğu dizin adı ve bir rakamla
harmanlayıp container adı (ör: <code>dockercomposedemo_api_1</code>) yaratır. Yalnızca tek bir container başlatacağınızdan
eminseniz servis tanımlarına</p><pre tabindex=0><code>container_name: demo-api
</code></pre><p>yazarak bu isimle açılmasını <a href=https://docs.docker.com/compose/compose-file/#containername>sağlayabilirsiniz</a>. Bu
durumda birden fazla container başlatmaya çalışırsanız hata alırsınız.</p><p>Servisimizin adının altında bir kez daha girintileme ile yazdığımız her şey servisi tanımlayan ayarlar olarak
algılanır. Şimdi gelin; sırasıyla yazdıklarımızı anlamaya çalışalım:</p><h4 id=build->build: .<a hidden class=anchor aria-hidden=true href=#build->#</a></h4><p>Kısaca imajı oluşturulacak Dockerfile dosyasının yerini (build context) belirtmek için kullanılır. Bizim projemizde
Dockerfile, YML dosyasıyla aynı dizinde bulunduğu için &ldquo;.&rdquo; (nokta) ile bu dizini işaret ediyoruz. Dilerseniz farklı bir
dizindeki Dockerfile’ı işaret edebilir, Dockerfile yerine farklı bir isim kullanıyorsanız ya da imajı yaratabilmek için
ek parametrelere ihtiyaç duyuyorsanız bunları da bu kısımda belirtebilirsiniz. Detaylar için
<a href=https://docs.docker.com/compose/compose-file/#build>tık tık</a>.</p><p><a href=https://docs.docker.com/swarm/>Swarm</a> modunda bu parametre gözardı edilmekte ve bir alttaki image parametresi
kullanılmaktadır.</p><h4 id=image-tunixdocker-compose-demo>image: tunix/docker-compose-demo<a hidden class=anchor aria-hidden=true href=#image-tunixdocker-compose-demo>#</a></h4><p>İmajın derlenmesi sonucunda çıkacak Docker imajının adını bu komutla belirtiyoruz. Hiç bir şey yazmazsanız yine
bulunduğunuz dizin ve verdiğiniz servis adını harmanlayarak bir isim (ör: <code>dockercomposedemo_api</code>) oluşturulacaktır.</p><h4 id=ports>ports<a hidden class=anchor aria-hidden=true href=#ports>#</a></h4><p>YML dosya biçiminde &ldquo;-&rdquo; ile başlayan kısımlar üstündeki satırı dizi (array) olarak tanımlar. Yani birden fazla &ldquo;-&rdquo; ile
başlayan satır yazarak, ports dizisine birden çok erişim noktası (port) ekleyebilirsiniz. Bizim örneğimiz için
konuşursak; ev sahibi (host) makinedeki 8080. erişim noktasını, container içerisindeki 8080 numaralı erişim noktasına
bağlıyoruz.</p><p>Bir erişim noktası, ev sahibi makinede yalnızca 1 kez kullanılabilir. Bu nedenle herhangi bir servisi, aynı ev sahibi
makinede birden fazla kez çalıştırmayı düşünüyorsanız bu kısımda yalnızca container’a ait olan erişim noktasını
belirtmelisiniz. Bu durumda, Compose container’ınıza ev sahibi makineden rastgele bir erişim noktası atar.</p><h4 id=links>links<a hidden class=anchor aria-hidden=true href=#links>#</a></h4><p>Altındaki tanımdan anlayacağınız üzere, &ldquo;links&rdquo; de bir dizi olup birden çok tanımlama
<a href=https://docs.docker.com/compose/compose-file/#links>kabul edebilir</a>. Bir container, diğerine erişeceğinde bunun en
kolay yolu bu container’ları birbirine bağlamaktır. Yazım şekline bakarsak &ldquo;:&rdquo; karakterinin solundaki servis adı,
sağındakiyse takma addır. Container içinden veritabanına ulaşacağımızda bu takma adı kullanıyor olacağız. Bu, bizi
gereksiz yere IP tanımlamaktan kurtacaktır. Proje içerisindeki
<a href=https://github.com/tunix/docker-compose-demo/blob/master/src/main/resources/application.yml>application.yml</a>
dosyasına bakarsanız MySQL için kullandığımız bağlantı cümlesinde (connection string) takma ad olan <code>demodb</code> kelimesini
kullandığımızı görebilirsiniz. Takma ad kullanmanın avantajı; servis adı değişse bile takma adın değişmemesidir.
Böylece kodumuzda değişiklik yapmak zorunda kalmıyoruz.</p><p><a href=https://docs.docker.com/swarm/>Swarm</a> modunda bu parametre gözardı edilmektedir.</p><h4 id=command>command<a hidden class=anchor aria-hidden=true href=#command>#</a></h4><p>Container başlatılırken çalıştırılacak komutun ne olacağını belirler.</p><p>Serinin önceki yazılarında <a href=https://alperkan.at/tr/2016/10/docker-serisi-3/>bahsettiğim</a> gibi, bu tanım aslında Dockerfile içinde de
yapılabiliyor. Burada tekrar yapma sebebim, Compose’un yapısından kaynaklanıyor. Tahmin edebileceğiniz gibi MySQL
başlayana kadar DB container’ındaki 3306 erişim noktası açık değil. Bu durumda uygulamam ayağa kalkarken bağlanamayıp
hata verecektir. Bunu engellemek için erişim noktasını sürekli yoklayıp açılınca uygulamayı başlatan
<a href=https://github.com/tunix/docker-compose-demo/blob/master/wait-for-it.sh>wait-for-it.sh</a> adında bir betik (script)
kullanıyorum.</p><h4 id=environment>environment<a hidden class=anchor aria-hidden=true href=#environment>#</a></h4><p>İmaj içerisinde tanımlı olan çevresel değişkenleri, yeni bir container başlatırken bu şekilde değiştirebiliyor,
tanımlayabiliyorsunuz. DB servisi için belirttiğim değişkenler, container ayağa kalktığında çalışan betiğin, benim
istediğim isimle bir veritabanı yaratmasını ve yine istediğim kullanıcı adı ve şifreyle çalışmasını sağlıyor.</p><p>Yalnızca 20 satırlık bu
<a href=https://github.com/tunix/docker-compose-demo/blob/master/docker-compose.yml>docker-compose.yml</a> dosyasıyla API
container’ının imajının yaratılmasını, ondan da bir container ayağa kaldırılmasını ve MySQL imajından DB adında bir
container yaratılmasını sağlayabiliyorsunuz. Tabii ki yapabilecekleriniz bunlarla sınırlı değil.
<a href=https://docs.docker.com/compose/compose-file/>Ekleyebileceğiniz diğer parametrelerle</a> container kayıtlarının nereye
yazılacağını, container yükleme (deployment) stratejilerinin belirlenmesini, bağlanacak dosya/dizinleri ve daha pek çok
ayarı yapabilirsiniz.</p><p>Serinin ilerleyen bölümlerinde farklı proje örneklerinde Compose’u nasıl kullanabileceğinizi işliyor olacağım.</p><h3 id=compose-ile-çalışmak>Compose ile Çalışmak<a hidden class=anchor aria-hidden=true href=#compose-ile-çalışmak>#</a></h3><p>YML dosyasını inceledikten sonra sıra geldi container’larımızı çalıştırmaya! Bunun için YML dosyasının bulunduğu dizine
gidin ve şu komutu çalıştırın:</p><pre tabindex=0><code>docker-compose up -d
</code></pre><p>Bu komut container’ları yaratacak, servisleri başlatacak ve sonrasında da çıkış yapacak. <code>-d</code> ya da uzun haliyle
<code>--daemon</code> parametresi, komutun arka planda (daemon) çalışmasını sağlar. Çalıştıklarını da teyid edelim:</p><figure><img loading=lazy src=docker_compose_ps_ciktisi.png alt="docker-compose ps"><figcaption><p>docker-compose ps</p></figcaption></figure><p>Dikkat ederseniz API servisimizin erişim noktası (8080) dışarıya açık ve erişilebilir durumdayken, DB servisimiz için
aynı durum geçerli değil. Bunun sebebi, Compose’un YML dosyasında bu erişim noktasını açmamış olmamızdan kaynaklanıyor.
Eğer veritabanınıza dışarıdan erişebilmek isterseniz dosyayı değiştirip erişim noktasını açmalı ve servisleri yeniden
ayağa kaldırmalısınız.</p><p>Erişim noktası açık olmamasına rağmen, API servisi veritabanına bağlanabiliyor çünkü Compose container’ların kendi
arasında iletişimi için özel bir ağ yarattı ve yukarıda bahsettiğim gibi, DB servisinin IP adresi <code>demodb</code> adıyla API
servisine ait container tarafından ulaşılabilir durumda.</p><p>Compose’un yarattığı bu ağ, servislerin izolasyonu açısından oldukça önemli. Serinin ilerleyen bölümlerinde göreceğimiz
üzere, YML dosyasında yapacağınız bir takım değişikliklerle birden çok Compose YML dosyasıyla yönettiğiniz servisleri
aynı ağa bağlamanız mümkün.</p><p>Artık servisimiz ayakta olduğuna göre istek atıp üstünde çalışabiliriz:</p><figure><img loading=lazy src=servis_istek_ciktisi.png alt="Spring Boot ile yazılmış HATEOAS REST API, DB’den aldığı sonuçları dönüyor."><figcaption><p>Spring Boot ile yazılmış HATEOAS REST API, DB’den aldığı sonuçları dönüyor.</p></figcaption></figure><pre tabindex=0><code>docker-compose down
</code></pre><p>komutunu vererek tüm servislerin kapatılmasını ve bunlara bağlı olarak yaratılmış ağ ile tüm container’ların
silinmesini sağlayabilirsiniz:</p><figure><img loading=lazy src=docker_compose_down_ciktisi.png alt="docker-compose down komut çıktısı"><figcaption><p>docker-compose down komut çıktısı</p></figcaption></figure><p>Kolaylık olması açısından oluşturulan imajlar silinmiyor. Bu sayede bir sonraki sefer <code>docker-compose up -</code>d komutunu
verdiğinizde servisleriniz çok daha hızlı ayağa kaldırılır. Eğer imajları da silmek isterseniz;</p><pre tabindex=0><code>docker-compose down --rmi all
</code></pre><p>komutunu verebilirsiniz.</p><h3 id=ipucu-1>İpucu #1<a hidden class=anchor aria-hidden=true href=#ipucu-1>#</a></h3><p>Diyelim ki; Ubuntu bazlı bir Docker imajınız var ve her ayağa kalkışında aşağıdaki komutları çalıştırıyor:</p><pre tabindex=0><code>apt-get update
apt-get upgrade
</code></pre><p>Daha farklı bir senaryo olarak, container’ınız ayağa kalkarken bir betik çalıştırarak git deponuzdaki kodun son halini
de alıyor olabilir örneğin. Bu gibi senaryolarda down komutuyla her şeyi kaldırmak yerine;</p><pre tabindex=0><code>docker-compose stop
</code></pre><p>komutuyla ağı ve tüm servisleri geçici olarak pasifize edebilir, ihtiyacınız olduğunda da;</p><pre tabindex=0><code>docker-compose start
</code></pre><p>komutuyla yeniden başlatabilirsiniz.</p><h3 id=ipucu-2>İpucu #2<a hidden class=anchor aria-hidden=true href=#ipucu-2>#</a></h3><p>Klasik Docker komutlarından farklı olarak Compose da <code>logs</code>, <code>restart</code>, <code>rm</code>, <code>exec</code> vb. pek çok komutu sağlıyor.
Bunların amaçlarını ve kullanım şekillerini örneğin;</p><pre tabindex=0><code>docker-compose logs --help
</code></pre><p>komutuyla görüntüleyebilirsiniz.</p><h3 id=ipucu-3>İpucu #3<a hidden class=anchor aria-hidden=true href=#ipucu-3>#</a></h3><p>Yukarıdaki örnekte bir API servisi, bir de DB servisi çalıştırmıştık. Aşağıdaki komutla istediğiniz servisten, istediğiniz adette başlatabilirsiniz:</p><pre tabindex=0><code>docker-compose scale api=2 db=1
</code></pre><p>Tabii uygulamanızın da buna hazır olması kaydıyla! 😉</p><figure><img loading=lazy src=docker_compose_scale_ciktisi.png></figure><hr><p>Bu bölümünün de sonuna geldik. Bir sonraki bölümde <a href=https://docs.docker.com/machine/>Docker Machine</a> ve
<a href=https://docs.docker.com/swarm/>Docker Swarm</a>’dan bahsedeceğim.</p><p>Gidişâta göre bu planda zaman zaman değişiklikler yapacak olsam da serinin tüm bölümlerinin planına
<a href=https://www.evernote.com/l/AB7CctYtJkpMUJsae1_3FgzIXgMY5MvFQhU>şuradan</a> ulaşabilirsiniz.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://alperkan.at/tr/tags/yaz%C4%B1l%C4%B1m/>yazılım</a></li><li><a href=https://alperkan.at/tr/tags/docker/>docker</a></li><li><a href=https://alperkan.at/tr/tags/docker-serisi/>docker serisi</a></li><li><a href=https://alperkan.at/tr/tags/container/>container</a></li><li><a href=https://alperkan.at/tr/tags/sanalla%C5%9Ft%C4%B1rma/>sanallaştırma</a></li><li><a href=https://alperkan.at/tr/tags/linux/>linux</a></li><li><a href=https://alperkan.at/tr/tags/devops/>devops</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://alperkan.at/tr/>Alper Kanat</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById("menu");menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>