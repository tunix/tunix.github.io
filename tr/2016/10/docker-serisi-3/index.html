<!doctype html><html lang=tr dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Docker Serisi #3 -- Docker Engine Bölüm 2 | Alper Kanat</title><meta name=keywords content="yazılım,docker,docker serisi,container,sanallaştırma,linux,devops"><meta name=description content="Docker Serisi’nin 3. bölümüne hoşgeldiniz! İlk bölümde sanallaştırmanın ne olduğundan, container teknolojisinden ve temel Docker kavramlarından; ikinci bölümde Docker Engine ve Docker komutlarından bahsetmiştim. Bu bölümdeyse özetle şu konulara değineceğim:
Kalıcı Veri Depolama Çevresel Değişkenler Bağlantı Noktaları Dockerfile Kendi İmajınızı Hazırlamak Docker Store & Registry Kendi Docker Registry’nizi Kurun Hızlıca başlayalım! 🙂
Kalıcı Veri Depolama İkinci bölümün docker run komutuyla ilgili olan kısmında container’lara dışarıdan dosya ve dizin bağlanabileceğinden bahsetmiştim. Normalde, ölçeklenebilirliğin ön planda olduğu gerçek ortam container’ları dışarıdan bağımsız çalışabilecek şekilde tasarlanmalıdır."><meta name=author content><link rel=canonical href=https://alperkan.at/tr/2016/10/docker-serisi-3/><link crossorigin=anonymous href=/assets/css/stylesheet.min.2d6dbfc6e0f8a1db1c9d082a76dc11d094328cf63f247bbc2421dfaa7f2bb170.css integrity="sha256-LW2/xuD4odscnQgqdtwR0JQyjPY/JHu8JCHfqn8rsXA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://alperkan.at/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://alperkan.at/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://alperkan.at/favicon-32x32.png><link rel=apple-touch-icon href=https://alperkan.at/apple-touch-icon.png><link rel=mask-icon href=https://alperkan.at/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.102.3"><link rel=alternate hreflang=tr href=https://alperkan.at/tr/2016/10/docker-serisi-3/><script async src="https://www.googletagmanager.com/gtag/js?id=G-SDT9Y68PM3"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-SDT9Y68PM3",{anonymize_ip:!1})}</script><meta property="og:title" content="Docker Serisi #3 -- Docker Engine Bölüm 2"><meta property="og:description" content="Docker Serisi’nin 3. bölümüne hoşgeldiniz! İlk bölümde sanallaştırmanın ne olduğundan, container teknolojisinden ve temel Docker kavramlarından; ikinci bölümde Docker Engine ve Docker komutlarından bahsetmiştim. Bu bölümdeyse özetle şu konulara değineceğim:
Kalıcı Veri Depolama Çevresel Değişkenler Bağlantı Noktaları Dockerfile Kendi İmajınızı Hazırlamak Docker Store & Registry Kendi Docker Registry’nizi Kurun Hızlıca başlayalım! 🙂
Kalıcı Veri Depolama İkinci bölümün docker run komutuyla ilgili olan kısmında container’lara dışarıdan dosya ve dizin bağlanabileceğinden bahsetmiştim. Normalde, ölçeklenebilirliğin ön planda olduğu gerçek ortam container’ları dışarıdan bağımsız çalışabilecek şekilde tasarlanmalıdır."><meta property="og:type" content="article"><meta property="og:url" content="https://alperkan.at/tr/2016/10/docker-serisi-3/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2016-10-13T00:00:00+00:00"><meta property="article:modified_time" content="2021-04-25T17:47:11+03:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Docker Serisi #3 -- Docker Engine Bölüm 2"><meta name=twitter:description content="Docker Serisi’nin 3. bölümüne hoşgeldiniz! İlk bölümde sanallaştırmanın ne olduğundan, container teknolojisinden ve temel Docker kavramlarından; ikinci bölümde Docker Engine ve Docker komutlarından bahsetmiştim. Bu bölümdeyse özetle şu konulara değineceğim:
Kalıcı Veri Depolama Çevresel Değişkenler Bağlantı Noktaları Dockerfile Kendi İmajınızı Hazırlamak Docker Store & Registry Kendi Docker Registry’nizi Kurun Hızlıca başlayalım! 🙂
Kalıcı Veri Depolama İkinci bölümün docker run komutuyla ilgili olan kısmında container’lara dışarıdan dosya ve dizin bağlanabileceğinden bahsetmiştim. Normalde, ölçeklenebilirliğin ön planda olduğu gerçek ortam container’ları dışarıdan bağımsız çalışabilecek şekilde tasarlanmalıdır."><script type=application/ld+json>
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://alperkan.at/tr/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Docker Serisi #3 -- Docker Engine Bölüm 2",
      "item": "https://alperkan.at/tr/2016/10/docker-serisi-3/"
    }
  ]
}
</script><script type=application/ld+json>
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Docker Serisi #3 -- Docker Engine Bölüm 2",
  "name": "Docker Serisi #3 -- Docker Engine Bölüm 2",
  "description": "Docker Serisi’nin 3. bölümüne hoşgeldiniz! İlk bölümde sanallaştırmanın ne olduğundan, container teknolojisinden ve temel Docker kavramlarından; ikinci bölümde Docker Engine ve Docker komutlarından bahsetmiştim. Bu bölümdeyse özetle şu konulara değineceğim:\nKalıcı Veri Depolama Çevresel Değişkenler Bağlantı Noktaları Dockerfile Kendi İmajınızı Hazırlamak Docker Store \u0026amp; Registry Kendi Docker Registry’nizi Kurun Hızlıca başlayalım! 🙂\nKalıcı Veri Depolama İkinci bölümün docker run komutuyla ilgili olan kısmında container’lara dışarıdan dosya ve dizin bağlanabileceğinden bahsetmiştim. Normalde, ölçeklenebilirliğin ön planda olduğu gerçek ortam container’ları dışarıdan bağımsız çalışabilecek şekilde tasarlanmalıdır.",
  "keywords": [
    "yazılım", "docker", "docker serisi", "container", "sanallaştırma", "linux", "devops"
  ],
  "articleBody": "Docker Serisi’nin 3. bölümüne hoşgeldiniz! İlk bölümde sanallaştırmanın ne olduğundan, container teknolojisinden ve temel Docker kavramlarından; ikinci bölümde Docker Engine ve Docker komutlarından bahsetmiştim. Bu bölümdeyse özetle şu konulara değineceğim:\nKalıcı Veri Depolama Çevresel Değişkenler Bağlantı Noktaları Dockerfile Kendi İmajınızı Hazırlamak Docker Store \u0026 Registry Kendi Docker Registry’nizi Kurun Hızlıca başlayalım! 🙂\nKalıcı Veri Depolama İkinci bölümün docker run komutuyla ilgili olan kısmında container’lara dışarıdan dosya ve dizin bağlanabileceğinden bahsetmiştim. Normalde, ölçeklenebilirliğin ön planda olduğu gerçek ortam container’ları dışarıdan bağımsız çalışabilecek şekilde tasarlanmalıdır. Aslında bakarsanız ölçeklenebilirliğin maksimize edilmesi için uygulamanızın, 12 Faktör prensibine uygun tasarlanmış olması gerekir. Bu prensiplere uyarak örneğin uygulamanızdan N tane container başlatarak ölçeklenebilirliği rahatlıkla sağlayabilirsiniz.\nÖlçeklenebilirliğin çok sorun olmadığı durumlarda ya da geliştirme/test ortamlarında dosya/dizin bağlamak size büyük kolaylık sağlar. Örneğin uygulama kayıtlarınızı (log) merkezi bir servis yerine yerel dosya sistemine yazıyorsanız, ilgili dizini ev sahibi makineye bağlamak akılcı olacaktır. Ya da uygulamalarınızı Tomcat’e dizin açarak yüklüyorsanız webapps dizinini ev sahibi makineye bağlamak isteyebilirsiniz.\nContainer’larda kalıcı veri depolama (persistence) söz konusu olduğunda 3 tip depolamadan bahsetmek mümkün:\nEv sahibi makineden dizin/dosya bağlayarak depolamak Bu yöntemde ev sahibi makineyi paylaşımlı dizin gibi düşünebiliriz. Bir kaç örnek senaryo sayarsam:\nnginx kurarken /etc/nginx/nginx.conf’u ev sahibi makineden bağlayarak üzerinde değişiklik yapmayı kolaylaştırmak nginx imajında hiç bir değişiklik yapmaksızın ev sahibi makinede tuttuğum statik web uygulamamın dizinini /var/www/html dizinine bağlayarak doğrudan sunmak Ev sahibi makinede tuttuğum, PHP ile geliştirdiğim kod tabanımı container ile paylaşarak yaptığım değişikliklerin sonucunu container üstünden anında görmek Ev sahibi makinede bulunan bir dizindeki tüm dosyaları, container’ın içinde çalışacak bir program ile işleyip aynı dizine yeniden yazmak Ev sahibi makinede çalışan Docker Engine’in çalışma dizinini, container’a bağlayarak Docker Engine’de bazı işlemler yapmak (ör: docker-cleanup) Peki dosya ya da dizinleri nasıl bağlıyoruz? Yukarıdaki bir kaç örneği gerçekleyelim:\nDışarıdan /etc/nginx/nginx.conf’u bağlamak:\ndocker run -d --name nginx1 -v /home/alper/nginx/nginx.conf:/etc/nginx/nginx.conf -p 8000:80 nginx Dışarıdan statik web uygulamasının dizinini bağlamak:\ndocker run -d --name nginx2 -v /home/alper/web:/var/www/html -p 8001:80 nginx Dışarıdan dizin bağlayıp içindeki dosyaları işlemek:\ndocker run --rm -v /home/alper/test:/test ubuntu sed ‘/kanat/d’ /test/deneme.txt Depolayıcı container’lar kullanmak Kalıcı veri depolamanın Docker’ca yolu, depolayıcı container’lar kullanmaktan geçiyor. Depolayıcı container’ların avantajları kabaca şöyle:\nİlgili alanı birden fazla container ile paylaşabilirsiniz. Bir container’a birden fazla depolayıcı container bağlayabilirsiniz. Depolayıcı container’lar, beraber çalıştıkları container’lar ölse dahi silinmez; tekrar tekrar kullanılabilirler. Depolayıcı container yaratmak için;\ndocker create -v /dbdata --name dbstore training/postgres /bin/true Depolayıcı container’ı bağlamak için;\ndocker run -d --volumes-from dbstore --name db1 training/postgres yazabilirsiniz. Bu sayede db1 adındaki container’ınızın içindeki /dbdata dizini, aslında dbstore container’ından bağlanmış olacaktır. Diyelim ki; disk alanını yedeklemek istiyoruz. Yeni bir container ile aynı depolayıcı container’ı bağlayarak bu işlemi gerçekleştirebiliriz:\ndocker run --rm --volumes-from dbstore -v $(pwd):/backup ubuntu tar cvf /backup/backup.tar /dbdata Bu komutun yaptıklarını kısaca özetlersek;\nÇalıştıktan sonra silinecek şekilde, Ubuntu imajından yeni bir container yarat (docker run --rm) Bu container’a dbstore adlı depolayıcı container’ından dışarı açılan dizinleri bağla (--volumes-from dbstore) Ev sahibi makine üstünde bulunduğum dizini, container içerisindeki /backup dizinine bağla. (-v $(pwd):/backup) Container üstündeki /dbdata dizinini sıkıştırarak ev sahibi makine üstünde /backup/backup.tar olarak kaydet. Paylaşımlı Disk Alanları Kullanmak Docker, 1.8.0 sürümünden itibaren disk alanları için sürücü desteğiyle beraber geliyor. Az sonra bahsedeceğim komutlara ek olarak; Azure, Google Compute Engine, NFS vb. sürücüleri parametre olarak geçerek (ör: --volume-driver=flocker) farklı servislerden disk alanlarını da container’larınıza bağlayabilirsiniz. Herhangi bir sürücü belirtmezseniz öntanımlı olan yerel disk sürücüsü (--volume-driver=local) kullanılır ve disk alanı makinenizde oluşturulur.\nYerel disk alanı yaratmak için:\ndocker volume create --name=shared-disk [Yükledikten sonra] flocker sürücüsü ile yaratmak için:\ndocker volume create -d flocker -o size=20GB --name=shared-disk Oluşturduğunuz disk alanını container’daki bir bölüme bağlamak için:\ndocker run -d --name=t1 -v shared-disk:/usr/local/tomcat/webapps -P tomcat docker run -d --name=t2 -v shared-disk:/usr/local/tomcat/webapps -P tomcat Yukarıdaki şekilde 2 tane Tomcat sunucusu başlatıp aynı disk alanını ikisine birden bağlayabiliyoruz.\nÇevresel Değişkenler İster web uygulaması olsun, ister bir API uygulaması; bir uygulamanın en önemli kısımlarından biri yapılandırma kısmıdır. Bazen bu yapılandırma, uygulamada kullanılan 3. parti servislerin erişim bilgileridir, bazense uygulamanın nasıl davranacağını belirleyen kritik roldeki bir anahtardır. Yalnızca bir anahtarın değerini değiştirerek gerçek bir veritabanı yerine örnek verilerle çalışmasını sağlayabilir ya da uygulama içindeki bir özelliği komple açıp kapatabilirsiniz.\nEski tip yazılım paketleme yöntemlerinde; uygulama içerisinde tutulan yapılandırma dosyalarının değerleriyle oynayıp birden fazla paket çıkarmak oldukça yaygın. Docker’da ise imajınızı gerçek ortama göre hazırlayıp dışarıdan vereceğiniz çevresel değişkenlerle her şeyi yönetebilirsiniz.\nTanımlayacağınız çevresel değişkenler, container içerisinde işletim sistemi seviyesinde ve tüm uygulamalarda erişilebilir durumda olacaktır. Bu sayede yapılandırma dosyalarında ya da çalıştırma betiklerinde çevresel değişkenlerinizi kullanabilirsiniz. Bu sayede son derece esnek imajlar yaratmanız mümkün.\nÇevresel değişkenlerle ilgili serinin ilerleyen bölümlerinde gerçekçi örnekler vereceğim için şimdilik Tomcat ve MySQL özelinde 2 örnekle bu kısmı noktalıyorum:\nTomcat Manager Uygulaması Şifresini Belirlemek docker run -d -p 8080:8080 -e TOMCAT_PASS=”mypass” tutum/tomcat Burada tutum’un imajını kullanma sebebim; orjinal Tomcat imajlarında çevresel değişkenler ile şifre belirleme özelliğinin bulunmuyor oluşundan kaynaklanıyor.\nMySQL Yönetici Şifresini Belirlemek docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql Docker Hub’dan (yeni adıyla Docker Store) indirdiğiniz imajların hangi çevresel değişkenleri kullandığını anlamak için ilgili sayfalarına bakabilirsiniz. Maalesef bazı imajlarda bu detaylar yeterince belgelendirilmediği için imajların kaynak kodlarındaki Dockerfile dosyalarını incelemeniz gerekebilir.\nBağlantı Noktaları Bağlantı noktaları (port) dış dünya ile container’larınızın iletişimini sağlar. Bir web uygulaması geliştirdiğimizi varsayarsak, container’daki 80. bağlantı noktasını ev sahibi makinedeki herhangi bir bağlantı noktasına bağlamadan uygulamamıza erişemeyiz.\nDocker, çalışma zamanında özellikle belirtmediğiniz sürece, öntanımlı olarak herhangi bir bağlantı noktasını dışarıya açmayacaktır. İmaj hazırlanırken bağlantı noktalarının tanımları da Dockerfile içine yazılır. Ancak yine de container’ı çalıştırırken, -p ya da -P ile ev sahibi makineye bağlamazsanız dışarıdan erişilmez olacaktır.\nContainer’ın tanımladığı bağlantı noktalarını docker ps komutuyla görebilirsiniz: 0.0.0.0:80-\u003e80/tcp, 443/tcp Bu çıktıya baktığımızda 80. bağlantı noktasının ev sahibi makinedeki tüm ağlara bağlandığını, 443. bağlantı noktasının ise bağlanmadığını görüyoruz. Sadece bağlanmış olanları görmek için docker port container_adi (örnek: docker port nginx) komutunu da kullanabiliriz.\n80 (HTTP) ve 443 (HTTPS) Bağlantı Noktalarını Bağlayalım Aşağıdaki komutla ev sahibi makinenin 80. ve 443. bağlantı noktalarını, container’daki 80. ve 443. bağlantı noktalarına bağlayabiliriz:\ndocker run -d --name nginx -p 80:80 -p 443:443 nginx Bağlantı Noktalarını Rastgele Bağlayalım Java ile yazılmış bir Spring Boot uygulamanız olduğunu varsayalım. Spring Boot’un avantajlarından biri, Tomcat’i uygulamayla birlikte JAR olarak paketleyebiliyorsunuz. Şimdi uygulamamızı Docker imajı haline getirdiğimizi ve yukarıdaki yöntemle başlattığımızı düşünelim. Aynı ev sahibi makine üstünde bir bağlantı noktasını yalnızca bir container kullanabilir. Bu nedenle yeniden yukarıdaki yöntemi kullanmak isterseniz yalnızca -p 81:80 -p 444:443 yazarak başlatabilirsiniz.\nÖlçeklendirilebilirliğin önemli olduğu durumlarda bağlantı noktasını sürekli elle artırarak yeni container açmak pek kabul edilebilir bir yöntem değil. Bu nedenle doğru olan yöntem -P parametresini kullanarak container’da tanımlanmış tüm bağlantı noktalarının ev sahibi makinedeki rastgele bağlantı noktalarına atanmasını sağlamaktır. Serinin ileriki bölümlerinden “Günlük Kullanım Bölüm 1” içerisinde bu yöntemden daha detaylı bahsedeceğim.\nRastgele bağlantı noktası ataması için aşağıdaki komutu kullanabilirsiniz:\ndocker run -d --name nginx -P nginx Dockerfile Dockerfile ile ilgili en detaylı ve güncel bilgiyi kendi sitesinde bulabilirsiniz. Bu kısımda kısaca Dockerfile’ı neden ve nasıl kullanmanız gerektiğini anlatmaya çalışacağım. Dockerfile, özetle bir Docker imajını tarif eder. Hangi imajı baz alacağımızı, baz aldığımız imajın üstünde çalıştıracağımız komutları, oluşturacağımız dizinleri, dış kullanıma açılabilecek çevresel değişkenleri, bağlantı noktalarını ve disk alanlarını bu dosyada belirtiyoruz. Yine bir örnek üstünden ilerleyelim:\nHer Dockerfile, FROM satırıyla başlar. İmajımızı, node:6.2-slim imajını baz alarak yaratacağız. -slim’i imajı mümkün olduğunca küçültmek amacıyla kullanıyorum. İmajı ilk inşa ettiğimiz noktada ne kadar küçükten başlatabilirsek o kadar iyi. Bu nedenle Alpine Linux, *-slim vb. seçenekleriniz varsa mutlaka kullanın. Örneğin Java’yla yazılmış uygulamanızı Debian ya da Ubuntu imajını baz alıp üstüne Java kurarak oluşturmak yerine, doğrudan java imajlarını tercih etmelisiniz.\nZorunlu olmasa da, Docker Store vb. yerlerde sorgulanabilmesi ve sorumlunun açıkça görülebilmesi açısından MAINTAINER satırını kullanmanız iyi olur.\nADD komutuyla, bulunduğum dizini container’ın /srv dizinine kopyalıyorum. Uygulamamı bu dizinde tutuyor olacağım. Bu tercih tamamen size kalmış. İsterseniz /app vb. bir dizin de kullanabilirsiniz. Ya da Tomcat imajını baz alıyorsanız doğrudan uygulamanızı /usr/share/tomcat/webapps gibi bir dizin altına da kopyalayabilirsiniz. Bir sonraki satırda (WORKDIR) ise bundan sonraki komutların çalıştırılacağı dizini /srv olarak belirtiyorum.\nDockerfile’daki her satır diğer komutlardan bağımsız çalışır. WORKDIR /srv yerine cd /srv yazarsanız bu sonraki komutların yine / dizininde çalışmasına sebep olacaktır.\nSerinin ilk bölümündeki “İmaj ne demek?” kısmında bahsettiğim gibi, Docker imajları katmanlardan oluşur. Dockerfile’da yazdığınız, imaja bir şey ekleyen (ADD, COPY, RUN vb.) her satır, imaja yeni bir katman ekler; dolayısıyla boyutunu artırır. Bu nedenle, dosyanın yukarıdan aşağıya doğru okunduğunu unutmayarak, değişmeyecek kısımları mümkün olduğunca yukarıya eklemeli ve komutları zincirlemelisiniz. 8. satırdaki apt komutlarının zincirlenmesi, işletim sistemi güncellemelerinin tek bir katmanda yer almasını sağlıyor.\n9–12. satırlar arasında uygulamanın çalışması için gereken bağımlılıkları kurup (RUN), uygulamayı derliyoruz.\nsatırda NODE_ENV adında bir çevresel değişken tanımlayıp (NODE_ENV) öntanımlı değerini production yapıyoruz. Bu, yukarıda bahsettiğim gerçek ortama yönelik imaj oluşturma prensibiyle de örtüşüyor. Çalışma zamanında -e NODE_ENV=development parametresiyle öntanımlı değeri ezebiliyoruz.\nsatırda, 3000. bağlantı noktasının dışarıdan kullanılabileceğini (EXPOSE) belirtiyorum. Yukarıda belirttiğim gibi, çalışma zamanında -p 3000:3000 ya da -P gibi bir parametreyle bu bağlantı noktasını ev sahibi makineye bağlamam gerekiyor.\nSon olarak 17. satırdaki CMD komutuyla öntanımlı olarak, daha önce WORKDIR ile belirlediğimiz dizindeki (/srv) app.js dosyasının çalıştırılacağını belirtiyoruz. Bu satırda CMD yerine ENTRYPOINT kullanarak da aynı işi yapabilirdik ama CMD daha esnek olduğundan onu tercih edebiliriz. Serinin ikinci bölümünde bahsettiğim gibi docker run komutlarının sonunda cat vb. terminal komutlarını çağırabiliyoruz. Bunu CMD’e borçluyuz. ENTRYPOINT kullanıyor olsaydık, imaj için belirlenen komut dışında bir komutu çağıramıyor olacaktık.\nDockerfile’la ilgili bu kısmı diğer kullanışlı bazı komutları açıklayarak kapatayım:\nLABEL Oluşturulacak imajın sahip olacağı öntanımlı etiketleri belirler. Ölçeklenebilirliğin önemli olduğu durumlarda docker run ile etiket vermektense bu şekilde etiketler tanımlamak daha mantıklı ve kolay.\nLABEL type=\"node\" purpose=\"api\" role=\"core\" description=\"REST API\" VOLUME Yukarıdaki Kalıcı Veri Depolama kısmında bahsettiğim gibi container’lara dışarıdan disk alanları bağlayabiliyoruz. Dockerfile’a ekleyeceğiniz VOLUME komutlarıyla container içindeki disk alanlarının dışarıdan bağlanabileceğini belirtmiş oluyorsunuz.\nVOLUME [“/data”] VOLUME /data USER Container içinde çalışan süreçler siz aksini belirtmediğiniz sürece root kullanıcısıyla çalıştırılır. Bu da Docker’daki olası bir açığın kötüye kullanılmasıyla istenmeyen sonuçlara sebebiyet verebilir. Bu tip durumların önüne geçmek için özellikle proje bağımlılıklarını kurmadan önce USER komutunu vermiş olmanız iyi olur. Bu sayede bağımlılıkların dosya/dizin sahipliği de bu kullanıcıya ait olur.\nARG Çevresel durumların yetişmediği bazı durumlarda imajlarınızı parametrik üretmek isterseniz ARG komutuyla değişkenler ve öntanımlı değerlerini tanımlayabilirsiniz. Bu tanımlar docker build komutunda, imajınız yaratılırken kullanılır.\nARG user1=someuser ARG buildno=1 şeklinde değişkenler tanımladığınızı varsayarsak; örneğin buildno’yu imaj oluşturulurken değiştirmek isterseniz:\ndocker build --build-arg buildno=2 -t tunix/alperkan.at . şeklinde yapabilirsiniz.\nHEALTHCHECK Docker 1.12 ile eklenen bu özellik sayesinde container’ın olması gerektiği gibi çalışıp çalışmadığını kontrol eden bir komutun belirli sıklıkta ve belirli zaman dilimlerinde çalışmasını sağlayabilirsiniz. Bu metrikleri takip eden başka servislerle yeni bir container başlatılmasını, mevcut container’ın yeniden başlatılmasını sağlayabilir ya da çeşitli alarm sistemlerini tetikleyebilirsiniz.\nHEALTHCHECK --interval=5m --timeout=3s \\ CMD curl -f http://localhost/ || exit 1 Kendi İmajınızı Hazırlamak Diyelim ki elinizde, Docker’laştırmak istediğiniz bir projeniz var; ne yapmalısınız? Bu sorunun cevabını vermek için Monitise MEA’da açık kaynak olarak GitHub’a koyduğumuz Gerrit Dashboard Server projesini örnek olarak kullanacağım.\nProjeyi kendi makinenize indirdikten sonra;\nnpm install gulp komutlarıyla bağımlılıkları kurup projeyi derleyin. Son komutla, Node.js ile yazılmış projenin derlenmiş hali dist dizinine yerleştiriliyor. Bu dizini, node imajlarından birini baz alan bir container’ın içine kopyalayıp çalıştırmalıyım. Dockerfile’a bakarsak;\nGerrit Dashboard Server projesinden Docker imajı üretme işini Travis CI üstünde yapıyoruz. Öncelikle imajın doğru şekilde üretildiğinden emin olmak için kendi makinemizde kurulu olan Docker Engine üstünde deneyelim:\ndocker build -t gerrit-dashboard-server:1.0.2 . İşlem başarılı bir şekilde sonuçlandığında docker images komutunu verdiğinizde imajın oluşturulduğunu doğrulayabilmelisiniz.\nİmajı dağıtıma çıkarmadan önce kullanılabilecek parametrelerle birlikte doğru şekilde çalıştığından emin olun.\nOluşturduğunuz imajı başka bir makineye kopyalamak için 2 seçeneğiniz var:\nDocker Engine’den arşivlenmiş şekilde dışa aktarmak Docker Store benzeri bir servise yüklemek Docker Engine’den arşivlenmiş şekilde dışa aktarmak için;\ndocker save -o ~/Desktop/gerritdashboard-1.0.2.tar \\ gerrit-dashboard-server:1.0.2 komutunu kullanabilirsiniz. Oluşan tar dosyasını diğer makineye kopyaladıktan sonra yeniden içeri aktarım yapmak içinse;\ndocker load -i gerritdashboard-1.0.2.tar komutunu kullanabilirsiniz.\nDocker Store \u0026 Registry Docker imajlarını saklamanın en kolay yollarından birisi Docker Store’a yüklemek. Çoğunlukla baz imajları indirmek için en temel kaynak olarak kullandığımız Docker Hub (yeni adıyla Docker Store) aslında kendi imajlarımıza da ev sahipliği yapabilecek bir depo. Genele açık imajlarınızı sınırsızca yükleyebileceğiniz servis, özel imajlarınız için 5 adede kadar ücretsiz olanak sağlıyor. Sonrası içinse ücretli üyeliklerden birine geçilmesi gerekiyor.\nEğer oluşturduğunuz imajı herkese açık olarak yüklemenizde bir sakınca yoksa Docker Hub’a ücretsiz olarak yükleyebilirsiniz. Bunun için öncelikle servise kayıt olmalısınız. Kayıt olduktan sonra kullanıcı bilgilerinizle giriş yapın ve yeni bir Docker imaj deposu (repository) oluşturun. Bunun için tercih edebileceğiniz 2 yol var:\nManuel Depo Docker Hub’da manuel depo oluşturma formu\nGiriş yaptıktan sonra sağ üstteki Create menüsünden Create Repository’e basın. Formdaki alanları doldurduktan sonra Create tuşuna basın. Şimdi imajı yükleme zamanı! 🤘🏻\nYükleme yapabilmek için bilgisayarınızdan Docker Hub’a giriş yapmak için;\ndocker login komutunu verin. E-posta adresinizi ve şifrenizi yazıp doğrulamadan geçtikten sonra ev dizininizdeki ~/.docker/config.json dosyasına ilgili servise ait giriş bilgileri (yetki kodu ve e-posta adresiniz) yazılacaktır. Bu işlem, aynı servisi kullandığınız sürece tek seferliktir; tekrarlamanız gerekmez.\nYukardaki son örneğimizden devam edelim. İmajımızı gerrit-dashboard-server:1.0.2 adıyla oluşturmuştuk. Docker Engine, imajı uzaktaki bir servise yükleyeceğimizde nereye yükleyeceğini imajın adından buluyor. Bu nedenle imajı yeniden oluşturmamıza gerek yok; etiketleri kullanarak işlemi gerçekleştirebiliriz. Docker Hub servisi için imajı etiketleyelim:\ndocker tag gerrit-dashboard-server:1.0.2 docker.io/tunix/gerritdashboard-server:1.0.2 Artık imajı Docker Hub’a yükleyebiliriz:\ndocker push docker.io/tunix/gerritdashboard-server:1.0.2 İşlem node imajını baz alıp üstüne sadece kendi katmanlarımızı eklediğimizden hızlıca tamamlanacaktır. Artık Docker Engine yüklü olan herhangi bir makinede;\ndocker pull docker.io/tunix/gerritdashboard-server:1.0.2 komutuyla imajı indirip kullanmaya başlayabilirsiniz.\nOtomatik Depo Docker Hub’da otomatik depo oluşturma formu\nGiriş yaptıktan sonra sağ üstteki Create menüsünden Create Automated Build’a basın. Karşınıza yukarıdaki gibi GitHub ya da Bitbucket arasında seçim yapmanız gereken bir ekran gelecek. Seçiminizi yaptığınızda ilgili servisin sitesine gidip kod depolarınıza erişim hakkı vermeniz gerekecektir. Bu adımı gerçekleştirdikten sonra kod depolarınızı seçmeniz için aşağıdaki gibi bir ekran göreceksiniz:\nGitHub kod depolarını listeleyen sayfadan istediğinizi seçin\nSeçiminizi yaptığınızda karşınıza otomatik depo oluşturmanın son adımı olan form çıkacaktır; formu doldurup Create tuşuna bastığınızda deponuz oluşturulacak ve ilk derleme işlemi için beklemeye başlayacaktır. Aslında kod deposu seçimini yaptığınızda arkaplanda seçim yaptığınız depoya bir webhook (ağ kancası? 😂) eklenir. Kod deposuna yeni kod parçacığı gönderdiğinizde Docker Hub’da otomatik olarak bir derlenme süreci tetiklenecek ve oluşturulan imajınız sayfada yer alacaktır.\nGitHub’daki digitalocean-dyndns adlı projemin Docker imajları Docker Hub tarafından otomatik oluşturuluyor.\nDocker Registry Docker Hub bu servisi verirken arkaplanda Docker Registry (yeni adıyla Docker Distribution) adı verilen açık kaynak kodlu bir yazılımı kullanıyor. Eğer imajlarınızı yüklemek için bir registry’e para vermek istemiyorsanız kendi registry’nizi kurabilirsiniz. Ancak böyle bir tercihte bulunacaksanız kurulum yapacağınız sunucunun yönetimini ve maliyetlerini de göz önünde bulundurun. Öte yandan proje kodlarını git vb. bir SKS (sürüm kontrol sistemi) üstünde tuttuğunuz sürece geriye dönüp imajı yeniden yaratmanız mümkün olabileceğinden riskiniz o kadar da yüksek değil. Yine de kodunuzun o anki hali değilse bile bulunduğu ortamın ve bağımlılıkların sıkıntı çıkarabileceğini unutmayın. 🤔\nKendi Docker Registry’nizi Kurun Monitise MEA’da hibrid bir geliştirme ve test ortamımız var. Klasik şekilde bir VM üstüne kurulu Tomcat’e yüklenen sayısız projemiz olduğu gibi, yeni projelerimizde Docker’ı kullanma seçeneğini her zaman göz önünde bulunduruyoruz. Gerçek ortamda Docker’ı hiç kullanmayan projelerde dahi bazı durumlarda geliştirme ve test ortamı için Docker’ı tercih edebiliyoruz. Dolayısıyla bu projelerin Docker imajlarını üretmemiz ve sunucular arasında taşımaya ihtiyacımız var ve Docker Registry burada devreye giriyor.\nÖzetle, Docker Registry bir API’dan ve disk üstünde imaj katmanlarını yöneten bir sistemden oluşuyor. API v1 iken Docker Registry adını taşırken, v2 ile birlikte Docker Distribution adını aldı. Her ikisi de Docker Store’dan indirilebilir durumda. Kurmak için;\ndocker run -d -p 5000:5000 --name registry registry:2 komutunu vermeniz yeterli. Bu durumda aşağıdaki öntanımlı değerler geçerli olur:\nİmajlarınız container içindeki /var/lib/registry dizini altına yazılır. Öntanımlı olarak filesystem sürücüsü kullanılır. Alternatifler şurada. Registry’nize, herhangi bir SSL sertifikasına sahip olmadığından, HTTP üstünden ulaşırsınız. Registry’niz herkesin yüklemesine ve indirmesine açık şekilde çalışır; kullanıcıların önce giriş yapmaları gerekmez. Kullandığınız ağın dışarıya açık olmaması durumunda bu şekilde de çalışabilirsiniz. Registry kurulumuyla ilgili en güncel bilgiyi şuradan bulabilirsiniz. Benim tavsiyem; registry için ev sahibi makineye ek disk vermeniz ve container’daki /var/lib/registry dizinini ev sahibi makinedeki /registry dizinine bağlamanız yönünde. Ayrıca registry’i kullanan tüm makinelerde ek ayar (--insecure-registry) yapmamak için sunucuya geçerli bir sertifika kurmanızda fayda var. LetsEncrypt gibi güzelliklerin olduğu günümüzde yapmazsanız ayıp! 😉 Tabii sertifika işini registry’nin önüne bir HTTP sunucusu (nginx, Apache vb.) koyarak da çözebilirsiniz. Hatta HTTP sunucusu yerine https-proxy’i de kullanabilirsiniz.\nSon durumda registry kurulumu için aşağıdaki gibi bir komuta ihtiyacınız var:\ndocker run -d --name registry \\ -p 5000:5000 \\ --restart=always \\ -v /registry:/var/lib/registry \\ registry:2 https-proxy kullanmak isteyenlere bonus olarak örnek komutu ekleyeyim:\ndocker run -d --name registry-ssl \\ -e KEY=”$(cat registry.key)” \\ -e CERT=”$(cat registry.crt)” \\ -p 443:443 \\ -e PORT=5000 \\ --restart=always \\ --link registry:www \\ yajo/https-proxy registry container’ını yaratırken kullandığınız ismin, https-proxy’i yaratırken kullandığınız komuttaki –link bölümündeki registry ismiyle aynı olduğundan emin olun.\nDiyelim ki; registry’inize ulaştığınız adres docker.example.com olsun. Bu durumda imajlarınızı buraya yüklemek için docker.example.com/tunix/alperkan.at:1.0.2 gibi isimlendirmelisiniz. docker push komutuyla imajınızı yüklerken, Docker Engine otomatik olarak HTTPS protokolünü tercih edecektir. Bu nedenle SSL adımını atladıysanız ve kendi makinenizden yükleme yapıyorsanız Docker Engine ayarlarında yeni registry’inizi “Insecure Registries” bölümünden ekleyin. Linux’da bu arayüz geliyor mu emin değilim ama şuradaki adımları takip edebilirsiniz.\nBu bölümünün de sonuna geldik. Bir sonraki bölümde Docker Compose’dan ve özellikle birden fazla parçaya ihtiyaç duyan projelerinizi Docker ile nasıl kolayca ayağa kaldırabileceğinizden bahsedeceğim.\nGidişâta göre bu planda zaman zaman değişiklikler yapacak olsam da serinin tüm bölümlerinin planına şuradan ulaşabilirsiniz.\n",
  "wordCount" : "2842",
  "inLanguage": "tr",
  "datePublished": "2016-10-13T00:00:00Z",
  "dateModified": "2021-04-25T17:47:11+03:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://alperkan.at/tr/2016/10/docker-serisi-3/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Alper Kanat",
    "logo": {
      "@type": "ImageObject",
      "url": "https://alperkan.at/favicon.ico"
    }
  }
}
</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://alperkan.at/tr/ accesskey=h title="Alper Kanat (Alt + H)">Alper Kanat</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://alperkan.at/ title=🇬🇧 aria-label=🇬🇧>En</a></li></ul></span></div><ul id=menu><li><a href=https://alperkan.at/tr/arsiv title=arşiv><span>arşiv</span></a></li><li><a href=https://alperkan.at/tr/tags title=etiketler><span>etiketler</span></a></li><li><a href=https://alperkan.at/tr/hakkimda title=hakkımda><span>hakkımda</span></a></li><li><a href=https://github.com/tunix/notebook title=notlarım><span>notlarım</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Docker Serisi #3 -- Docker Engine Bölüm 2</h1><div class=post-meta>October 13, 2016</div></header><div class=post-content><p>Docker Serisi’nin 3. bölümüne hoşgeldiniz! <a href=https://alperkan.at/tr/2016/07/docker-serisi-1/>İlk bölümde</a> sanallaştırmanın ne olduğundan,
container teknolojisinden ve temel Docker kavramlarından; <a href=https://alperkan.at/tr/2016/09/docker-serisi-2/>ikinci bölümde</a> Docker Engine
ve Docker komutlarından bahsetmiştim. Bu bölümdeyse özetle şu konulara değineceğim:</p><ul><li><a href=#kalıcı-veri-depolama>Kalıcı Veri Depolama</a></li><li><a href=#çevresel-değişkenler>Çevresel Değişkenler</a></li><li><a href=#bağlantı-noktaları>Bağlantı Noktaları</a></li><li><a href=#dockerfile>Dockerfile</a></li><li><a href=#kendi-imajınızı-hazırlamak>Kendi İmajınızı Hazırlamak</a></li><li><a href=#docker-store--registry>Docker Store & Registry</a></li><li><a href=#kendi-docker-registrynizi-kurun>Kendi Docker Registry’nizi Kurun</a></li></ul><p>Hızlıca başlayalım! 🙂</p><hr><h3 id=kalıcı-veri-depolama>Kalıcı Veri Depolama<a hidden class=anchor aria-hidden=true href=#kalıcı-veri-depolama>#</a></h3><p><a href=https://alperkan.at/tr/2016/09/docker-serisi-2/#docker-run->İkinci bölümün docker run komutuyla ilgili olan kısmında</a> container’lara
dışarıdan dosya ve dizin bağlanabileceğinden bahsetmiştim. Normalde, ölçeklenebilirliğin ön planda olduğu gerçek ortam
container’ları dışarıdan bağımsız çalışabilecek şekilde tasarlanmalıdır. Aslında bakarsanız ölçeklenebilirliğin
maksimize edilmesi için uygulamanızın, <a href=https://12factor.net/>12 Faktör prensibine</a> uygun tasarlanmış olması gerekir.
Bu prensiplere uyarak örneğin uygulamanızdan N tane container başlatarak ölçeklenebilirliği rahatlıkla
sağlayabilirsiniz.</p><p>Ölçeklenebilirliğin çok sorun olmadığı durumlarda ya da geliştirme/test ortamlarında dosya/dizin bağlamak size büyük
kolaylık sağlar. Örneğin uygulama kayıtlarınızı (log) merkezi bir servis yerine yerel dosya sistemine yazıyorsanız,
ilgili dizini ev sahibi makineye bağlamak akılcı olacaktır. Ya da uygulamalarınızı Tomcat’e dizin açarak yüklüyorsanız
<code>webapps</code> dizinini ev sahibi makineye bağlamak isteyebilirsiniz.</p><p>Container’larda kalıcı veri depolama (persistence) söz konusu olduğunda 3 tip depolamadan bahsetmek mümkün:</p><h4 id=ev-sahibi-makineden-dizindosya-bağlayarak-depolamak>Ev sahibi makineden dizin/dosya bağlayarak depolamak<a hidden class=anchor aria-hidden=true href=#ev-sahibi-makineden-dizindosya-bağlayarak-depolamak>#</a></h4><p>Bu yöntemde ev sahibi makineyi paylaşımlı dizin gibi düşünebiliriz. Bir kaç örnek senaryo sayarsam:</p><ul><li>nginx kurarken <code>/etc/nginx/nginx.conf</code>’u ev sahibi makineden bağlayarak üzerinde değişiklik yapmayı kolaylaştırmak</li><li>nginx imajında hiç bir değişiklik yapmaksızın ev sahibi makinede tuttuğum statik web uygulamamın dizinini
<code>/var/www/html</code> dizinine bağlayarak doğrudan sunmak</li><li>Ev sahibi makinede tuttuğum, PHP ile geliştirdiğim kod tabanımı container ile paylaşarak yaptığım değişikliklerin
sonucunu container üstünden anında görmek</li><li>Ev sahibi makinede bulunan bir dizindeki tüm dosyaları, container’ın içinde çalışacak bir program ile işleyip aynı
dizine yeniden yazmak</li><li>Ev sahibi makinede çalışan Docker Engine’in çalışma dizinini, container’a bağlayarak Docker Engine’de bazı işlemler
yapmak (ör: <a href=https://github.com/meltwater/docker-cleanup>docker-cleanup</a>)</li></ul><p>Peki dosya ya da dizinleri nasıl bağlıyoruz? Yukarıdaki bir kaç örneği gerçekleyelim:</p><p><strong>Dışarıdan /etc/nginx/nginx.conf’u bağlamak:</strong></p><pre tabindex=0><code>docker run -d --name nginx1 -v /home/alper/nginx/nginx.conf:/etc/nginx/nginx.conf -p 8000:80 nginx
</code></pre><p><strong>Dışarıdan statik web uygulamasının dizinini bağlamak:</strong></p><pre tabindex=0><code>docker run -d --name nginx2 -v /home/alper/web:/var/www/html -p 8001:80 nginx
</code></pre><p><strong>Dışarıdan dizin bağlayıp içindeki dosyaları işlemek:</strong></p><pre tabindex=0><code>docker run --rm -v /home/alper/test:/test ubuntu sed ‘/kanat/d’ /test/deneme.txt
</code></pre><h4 id=depolayıcı-containerlar-kullanmak>Depolayıcı container’lar kullanmak<a hidden class=anchor aria-hidden=true href=#depolayıcı-containerlar-kullanmak>#</a></h4><p>Kalıcı veri depolamanın Docker’ca yolu, depolayıcı container’lar kullanmaktan geçiyor. Depolayıcı container’ların
avantajları kabaca şöyle:</p><ul><li>İlgili alanı birden fazla container ile paylaşabilirsiniz.</li><li>Bir container’a birden fazla depolayıcı container bağlayabilirsiniz.</li><li>Depolayıcı container’lar, beraber çalıştıkları container’lar ölse dahi silinmez; tekrar tekrar kullanılabilirler.</li></ul><p>Depolayıcı container yaratmak için;</p><pre tabindex=0><code>docker create -v /dbdata --name dbstore training/postgres /bin/true
</code></pre><p>Depolayıcı container’ı bağlamak için;</p><pre tabindex=0><code>docker run -d --volumes-from dbstore --name db1 training/postgres
</code></pre><p>yazabilirsiniz. Bu sayede <code>db1</code> adındaki container’ınızın içindeki <code>/dbdata</code> dizini, aslında <code>dbstore</code> container’ından
bağlanmış olacaktır. Diyelim ki; disk alanını yedeklemek istiyoruz. Yeni bir container ile aynı depolayıcı container’ı
bağlayarak bu işlemi gerçekleştirebiliriz:</p><pre tabindex=0><code>docker run --rm --volumes-from dbstore -v $(pwd):/backup ubuntu tar cvf /backup/backup.tar /dbdata
</code></pre><p>Bu komutun yaptıklarını kısaca özetlersek;</p><ul><li>Çalıştıktan sonra silinecek şekilde, Ubuntu imajından yeni bir container yarat (<code>docker run --rm</code>)</li><li>Bu container’a dbstore adlı depolayıcı container’ından dışarı açılan dizinleri bağla (<code>--volumes-from dbstore</code>)</li><li>Ev sahibi makine üstünde bulunduğum dizini, container içerisindeki <code>/backup</code> dizinine bağla. (<code>-v $(pwd):/backup</code>)</li><li>Container üstündeki <code>/dbdata</code> dizinini sıkıştırarak ev sahibi makine üstünde <code>/backup/backup.tar</code> olarak kaydet.</li></ul><h4 id=paylaşımlı-disk-alanları-kullanmak>Paylaşımlı Disk Alanları Kullanmak<a hidden class=anchor aria-hidden=true href=#paylaşımlı-disk-alanları-kullanmak>#</a></h4><p>Docker, 1.8.0 sürümünden itibaren disk alanları için sürücü desteğiyle beraber geliyor. Az sonra bahsedeceğim komutlara
ek olarak; Azure, Google Compute Engine, NFS vb. sürücüleri parametre olarak geçerek (ör: <code>--volume-driver=flocker</code>)
farklı servislerden disk alanlarını da container’larınıza
<a href=https://docs.docker.com/engine/tutorials/dockervolumes/>bağlayabilirsiniz</a>. Herhangi bir sürücü belirtmezseniz
öntanımlı olan yerel disk sürücüsü (<code>--volume-driver=local</code>) kullanılır ve disk alanı makinenizde oluşturulur.</p><p>Yerel disk alanı yaratmak için:</p><pre tabindex=0><code>docker volume create --name=shared-disk
</code></pre><p>[Yükledikten sonra] <a href=https://clusterhq.com/flocker/introduction/>flocker</a> sürücüsü ile yaratmak için:</p><pre tabindex=0><code>docker volume create -d flocker -o size=20GB --name=shared-disk
</code></pre><p>Oluşturduğunuz disk alanını container’daki bir bölüme bağlamak için:</p><pre tabindex=0><code>docker run -d --name=t1 -v shared-disk:/usr/local/tomcat/webapps -P tomcat
docker run -d --name=t2 -v shared-disk:/usr/local/tomcat/webapps -P tomcat
</code></pre><p>Yukarıdaki şekilde 2 tane Tomcat sunucusu başlatıp aynı disk alanını ikisine birden bağlayabiliyoruz.</p><h3 id=çevresel-değişkenler>Çevresel Değişkenler<a hidden class=anchor aria-hidden=true href=#çevresel-değişkenler>#</a></h3><p>İster web uygulaması olsun, ister bir API uygulaması; bir uygulamanın en önemli kısımlarından biri yapılandırma
kısmıdır. Bazen bu yapılandırma, uygulamada kullanılan 3. parti servislerin erişim bilgileridir, bazense uygulamanın
nasıl davranacağını belirleyen kritik roldeki bir anahtardır. Yalnızca bir anahtarın değerini değiştirerek gerçek bir
veritabanı yerine örnek verilerle çalışmasını sağlayabilir ya da uygulama içindeki bir özelliği komple açıp
kapatabilirsiniz.</p><p>Eski tip yazılım paketleme yöntemlerinde; uygulama içerisinde tutulan yapılandırma dosyalarının değerleriyle oynayıp
birden fazla paket çıkarmak oldukça yaygın. Docker’da ise imajınızı gerçek ortama göre hazırlayıp dışarıdan vereceğiniz
çevresel değişkenlerle her şeyi yönetebilirsiniz.</p><p>Tanımlayacağınız çevresel değişkenler, container içerisinde işletim sistemi seviyesinde ve tüm uygulamalarda
erişilebilir durumda olacaktır. Bu sayede yapılandırma dosyalarında ya da çalıştırma betiklerinde çevresel
değişkenlerinizi kullanabilirsiniz. Bu sayede son derece esnek imajlar yaratmanız mümkün.</p><p>Çevresel değişkenlerle ilgili serinin ilerleyen bölümlerinde gerçekçi örnekler vereceğim için şimdilik Tomcat ve MySQL
özelinde 2 örnekle bu kısmı noktalıyorum:</p><h4 id=tomcat-manager-uygulaması-şifresini-belirlemek>Tomcat Manager Uygulaması Şifresini Belirlemek<a hidden class=anchor aria-hidden=true href=#tomcat-manager-uygulaması-şifresini-belirlemek>#</a></h4><pre tabindex=0><code>docker run -d -p 8080:8080 -e TOMCAT_PASS=”mypass” tutum/tomcat
</code></pre><blockquote><p>Burada tutum’un imajını kullanma sebebim; orjinal Tomcat imajlarında çevresel değişkenler ile şifre belirleme
özelliğinin bulunmuyor oluşundan kaynaklanıyor.</p></blockquote><h4 id=mysql-yönetici-şifresini-belirlemek>MySQL Yönetici Şifresini Belirlemek<a hidden class=anchor aria-hidden=true href=#mysql-yönetici-şifresini-belirlemek>#</a></h4><pre tabindex=0><code>docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql
</code></pre><p>Docker Hub’dan (yeni adıyla Docker Store) indirdiğiniz imajların hangi çevresel değişkenleri kullandığını anlamak için
ilgili sayfalarına bakabilirsiniz. Maalesef bazı imajlarda bu detaylar yeterince belgelendirilmediği için imajların
kaynak kodlarındaki <a href=https://medium.com/commencis/docker-serisi-3-docker-engine-bolum-2-a7c6c5f50851#6aea>Dockerfile</a>
dosyalarını incelemeniz gerekebilir.</p><h3 id=bağlantı-noktaları>Bağlantı Noktaları<a hidden class=anchor aria-hidden=true href=#bağlantı-noktaları>#</a></h3><p>Bağlantı noktaları (port) dış dünya ile container’larınızın iletişimini sağlar. Bir web uygulaması geliştirdiğimizi
varsayarsak, container’daki 80. bağlantı noktasını ev sahibi makinedeki herhangi bir bağlantı noktasına bağlamadan
uygulamamıza erişemeyiz.</p><p>Docker, çalışma zamanında özellikle belirtmediğiniz sürece, öntanımlı olarak herhangi bir bağlantı noktasını dışarıya
açmayacaktır. İmaj hazırlanırken bağlantı noktalarının tanımları da <a href=#dockerfile>Dockerfile</a> içine
yazılır. Ancak yine de container’ı çalıştırırken, <code>-p</code> ya da <code>-P</code> ile ev sahibi makineye bağlamazsanız dışarıdan
erişilmez olacaktır.</p><p>Container’ın tanımladığı bağlantı noktalarını <code>docker ps</code> komutuyla görebilirsiniz: <code>0.0.0.0:80->80/tcp</code>, <code>443/tcp</code> Bu
çıktıya baktığımızda 80. bağlantı noktasının ev sahibi makinedeki tüm ağlara bağlandığını, 443. bağlantı noktasının
ise bağlanmadığını görüyoruz. Sadece bağlanmış olanları görmek için <code>docker port container_adi</code> (örnek:
<code>docker port nginx</code>) komutunu da kullanabiliriz.</p><h4 id=80-http-ve-443-https-bağlantı-noktalarını-bağlayalım>80 (HTTP) ve 443 (HTTPS) Bağlantı Noktalarını Bağlayalım<a hidden class=anchor aria-hidden=true href=#80-http-ve-443-https-bağlantı-noktalarını-bağlayalım>#</a></h4><p>Aşağıdaki komutla ev sahibi makinenin 80. ve 443. bağlantı noktalarını, container’daki 80. ve 443. bağlantı noktalarına
bağlayabiliriz:</p><pre tabindex=0><code>docker run -d --name nginx -p 80:80 -p 443:443 nginx
</code></pre><h4 id=bağlantı-noktalarını-rastgele-bağlayalım>Bağlantı Noktalarını Rastgele Bağlayalım<a hidden class=anchor aria-hidden=true href=#bağlantı-noktalarını-rastgele-bağlayalım>#</a></h4><p>Java ile yazılmış bir Spring Boot uygulamanız olduğunu varsayalım. Spring Boot’un avantajlarından biri, Tomcat’i
uygulamayla birlikte JAR olarak paketleyebiliyorsunuz. Şimdi uygulamamızı Docker imajı haline getirdiğimizi ve
yukarıdaki yöntemle başlattığımızı düşünelim. <em><strong>Aynı ev sahibi makine üstünde bir bağlantı noktasını yalnızca bir
container kullanabilir</strong></em>. Bu nedenle yeniden yukarıdaki yöntemi kullanmak isterseniz yalnızca <code>-p 81:80 -p 444:443</code>
yazarak başlatabilirsiniz.</p><p>Ölçeklendirilebilirliğin önemli olduğu durumlarda bağlantı noktasını sürekli elle artırarak yeni container açmak pek
kabul edilebilir bir yöntem değil. Bu nedenle doğru olan yöntem <code>-P</code> parametresini kullanarak container’da tanımlanmış
tüm bağlantı noktalarının ev sahibi makinedeki rastgele bağlantı noktalarına atanmasını sağlamaktır. Serinin ileriki
bölümlerinden &ldquo;Günlük Kullanım Bölüm 1&rdquo; içerisinde bu yöntemden daha detaylı bahsedeceğim.</p><p>Rastgele bağlantı noktası ataması için aşağıdaki komutu kullanabilirsiniz:</p><pre tabindex=0><code>docker run -d --name nginx -P nginx
</code></pre><h3 id=dockerfile>Dockerfile<a hidden class=anchor aria-hidden=true href=#dockerfile>#</a></h3><p>Dockerfile ile ilgili en detaylı ve güncel bilgiyi <a href=https://docs.docker.com/engine/reference/builder/>kendi sitesinde</a>
bulabilirsiniz. Bu kısımda kısaca Dockerfile’ı neden ve nasıl kullanmanız gerektiğini anlatmaya çalışacağım.
Dockerfile, özetle bir Docker imajını tarif eder. Hangi imajı baz alacağımızı, baz aldığımız imajın üstünde
çalıştıracağımız komutları, oluşturacağımız dizinleri, dış kullanıma açılabilecek çevresel değişkenleri, bağlantı
noktalarını ve disk alanlarını bu dosyada belirtiyoruz. Yine bir örnek üstünden ilerleyelim:</p><script type=application/javascript src=https://gist.github.com/tunix/ce6ad7fc6c8c075ab20ee7877307cb23.js></script><p>Her Dockerfile, <code>FROM</code> satırıyla başlar. İmajımızı, <code>node:6.2-slim</code> imajını baz alarak yaratacağız. <code>-slim</code>’i imajı
mümkün olduğunca küçültmek amacıyla kullanıyorum. İmajı ilk inşa ettiğimiz noktada ne kadar küçükten başlatabilirsek o
kadar iyi. Bu nedenle <a href=https://alpinelinux.org/>Alpine Linux</a>,
<a href=https://store.docker.com/images/e6658267-cc55-421e-b5be-5e69460fb0d1>*-slim</a> vb. seçenekleriniz varsa mutlaka
kullanın. Örneğin Java’yla yazılmış uygulamanızı Debian ya da Ubuntu imajını baz alıp üstüne Java kurarak oluşturmak
yerine, doğrudan <a href=https://store.docker.com/images/199a18b1-511b-47fd-b287-a41555fafb9f>java</a> imajlarını tercih
etmelisiniz.</p><p>Zorunlu olmasa da, <a href=https://store.docker.com/>Docker Store</a> vb. yerlerde sorgulanabilmesi ve sorumlunun açıkça
görülebilmesi açısından <code>MAINTAINER</code> satırını kullanmanız iyi olur.</p><p><code>ADD</code> komutuyla, bulunduğum dizini container&rsquo;ın <code>/srv</code> dizinine kopyalıyorum. Uygulamamı bu dizinde tutuyor olacağım.
Bu tercih tamamen size kalmış. İsterseniz <code>/app</code> vb. bir dizin de kullanabilirsiniz. Ya da Tomcat imajını baz
alıyorsanız doğrudan uygulamanızı <code>/usr/share/tomcat/webapps</code> gibi bir dizin altına da kopyalayabilirsiniz. Bir sonraki
satırda (<code>WORKDIR</code>) ise bundan sonraki komutların çalıştırılacağı dizini <code>/srv</code> olarak belirtiyorum.</p><blockquote><p>Dockerfile’daki her satır diğer komutlardan bağımsız çalışır. <code>WORKDIR /srv</code> yerine <code>cd /srv</code> yazarsanız bu sonraki
komutların yine <code>/</code> dizininde çalışmasına sebep olacaktır.</p></blockquote><p>Serinin ilk bölümündeki &ldquo;<a href=https://alperkan.at/tr/2016/07/docker-serisi-1/#imaj-ne-demek>İmaj ne demek?</a>&rdquo; kısmında bahsettiğim gibi,
Docker imajları katmanlardan oluşur. Dockerfile’da yazdığınız, imaja bir şey ekleyen (<code>ADD</code>, <code>COPY</code>, <code>RUN</code> vb.) her
satır, imaja yeni bir katman ekler; dolayısıyla boyutunu artırır. Bu nedenle, dosyanın yukarıdan aşağıya doğru
okunduğunu unutmayarak, değişmeyecek kısımları mümkün olduğunca yukarıya eklemeli ve komutları zincirlemelisiniz. 8.
satırdaki <code>apt</code> komutlarının zincirlenmesi, işletim sistemi güncellemelerinin tek bir katmanda yer almasını sağlıyor.</p><p>9–12. satırlar arasında uygulamanın çalışması için gereken bağımlılıkları kurup (<code>RUN</code>), uygulamayı derliyoruz.</p><ol start=14><li><p>satırda <code>NODE_ENV</code> adında bir çevresel değişken tanımlayıp (<code>NODE_ENV</code>) öntanımlı değerini <code>production</code> yapıyoruz.
Bu, yukarıda bahsettiğim gerçek ortama yönelik imaj oluşturma prensibiyle de örtüşüyor. Çalışma zamanında
<code>-e NODE_ENV=development</code> parametresiyle öntanımlı değeri ezebiliyoruz.</p></li><li><p>satırda, 3000. bağlantı noktasının dışarıdan kullanılabileceğini (<code>EXPOSE</code>) belirtiyorum. Yukarıda belirttiğim
gibi, çalışma zamanında <code>-p 3000:3000</code> ya da <code>-P</code> gibi bir parametreyle bu bağlantı noktasını ev sahibi makineye
bağlamam gerekiyor.</p></li></ol><p>Son olarak 17. satırdaki <code>CMD</code> komutuyla öntanımlı olarak, daha önce <code>WORKDIR</code> ile belirlediğimiz dizindeki (<code>/srv</code>)
<code>app.js</code> dosyasının çalıştırılacağını belirtiyoruz. Bu satırda <code>CMD</code> yerine <code>ENTRYPOINT</code> kullanarak da aynı işi
yapabilirdik ama CMD daha esnek olduğundan onu tercih edebiliriz. Serinin
<a href=https://alperkan.at/tr/2016/09/docker-serisi-2/#docker-run->ikinci bölümünde</a> bahsettiğim gibi <code>docker run</code> komutlarının sonunda <code>cat</code>
vb. terminal komutlarını çağırabiliyoruz. Bunu <code>CMD</code>’e borçluyuz. <code>ENTRYPOINT</code> kullanıyor olsaydık, imaj için
belirlenen komut dışında bir komutu çağıramıyor olacaktık.</p><p>Dockerfile’la ilgili bu kısmı diğer kullanışlı bazı komutları açıklayarak kapatayım:</p><h4 id=label>LABEL<a hidden class=anchor aria-hidden=true href=#label>#</a></h4><p>Oluşturulacak imajın sahip olacağı öntanımlı etiketleri belirler. Ölçeklenebilirliğin önemli olduğu durumlarda
<code>docker run</code> ile etiket vermektense bu şekilde etiketler tanımlamak daha mantıklı ve kolay.</p><pre tabindex=0><code>LABEL type=&#34;node&#34; purpose=&#34;api&#34; role=&#34;core&#34; description=&#34;REST API&#34;
</code></pre><h4 id=volume>VOLUME<a hidden class=anchor aria-hidden=true href=#volume>#</a></h4><p>Yukarıdaki <a href=#kalıcı-veri-depolama>Kalıcı Veri Depolama</a> kısmında bahsettiğim gibi container’lara
dışarıdan disk alanları bağlayabiliyoruz. Dockerfile’a ekleyeceğiniz <code>VOLUME</code> komutlarıyla container içindeki disk
alanlarının dışarıdan bağlanabileceğini belirtmiş oluyorsunuz.</p><pre tabindex=0><code>VOLUME [“/data”]
VOLUME /data
</code></pre><h4 id=user>USER<a hidden class=anchor aria-hidden=true href=#user>#</a></h4><p>Container içinde çalışan süreçler siz aksini belirtmediğiniz sürece <code>root</code> kullanıcısıyla çalıştırılır. Bu da
Docker’daki olası bir açığın kötüye kullanılmasıyla istenmeyen sonuçlara sebebiyet verebilir. Bu tip durumların önüne
geçmek için özellikle proje bağımlılıklarını kurmadan önce <code>USER</code> komutunu vermiş olmanız iyi olur. Bu sayede
bağımlılıkların dosya/dizin sahipliği de bu kullanıcıya ait olur.</p><h4 id=arg>ARG<a hidden class=anchor aria-hidden=true href=#arg>#</a></h4><p>Çevresel durumların yetişmediği bazı durumlarda imajlarınızı parametrik üretmek isterseniz <code>ARG</code> komutuyla değişkenler
ve öntanımlı değerlerini tanımlayabilirsiniz. Bu tanımlar <code>docker build</code> komutunda, imajınız yaratılırken kullanılır.</p><pre tabindex=0><code>ARG user1=someuser
ARG buildno=1
</code></pre><p>şeklinde değişkenler tanımladığınızı varsayarsak; örneğin buildno’yu imaj oluşturulurken değiştirmek isterseniz:</p><pre tabindex=0><code>docker build --build-arg buildno=2 -t tunix/alperkan.at .
</code></pre><p>şeklinde yapabilirsiniz.</p><h4 id=healthcheck>HEALTHCHECK<a hidden class=anchor aria-hidden=true href=#healthcheck>#</a></h4><p>Docker 1.12 ile eklenen <a href=https://docs.docker.com/engine/reference/builder/#/healthcheck>bu özellik</a> sayesinde
container’ın olması gerektiği gibi çalışıp çalışmadığını kontrol eden bir komutun belirli sıklıkta ve belirli zaman
dilimlerinde çalışmasını sağlayabilirsiniz. Bu metrikleri takip eden başka servislerle yeni bir container
başlatılmasını, mevcut container’ın yeniden başlatılmasını sağlayabilir ya da çeşitli alarm sistemlerini
tetikleyebilirsiniz.</p><pre tabindex=0><code>HEALTHCHECK --interval=5m --timeout=3s \
CMD curl -f http://localhost/ || exit 1
</code></pre><h3 id=kendi-imajınızı-hazırlamak>Kendi İmajınızı Hazırlamak<a hidden class=anchor aria-hidden=true href=#kendi-imajınızı-hazırlamak>#</a></h3><p>Diyelim ki elinizde, Docker’laştırmak istediğiniz bir projeniz var; ne yapmalısınız? Bu sorunun cevabını vermek için
<a href="https://medium.com/u/f570294a852c?source=post_page-----a7c6c5f50851--------------------------------">Monitise MEA</a>’da
açık kaynak olarak GitHub’a koyduğumuz
<a href=https://github.com/monitise-mea/gerrit-dashboard-server>Gerrit Dashboard Server</a> projesini örnek olarak kullanacağım.</p><p>Projeyi kendi makinenize indirdikten sonra;</p><pre tabindex=0><code>npm install
gulp
</code></pre><p>komutlarıyla bağımlılıkları kurup projeyi derleyin. Son komutla, <a href=https://nodejs.org/en/>Node.js</a> ile yazılmış
projenin derlenmiş hali <code>dist</code> dizinine yerleştiriliyor. Bu dizini,
<a href=https://store.docker.com/images/e6658267-cc55-421e-b5be-5e69460fb0d1>node</a> imajlarından birini baz alan bir
container’ın içine kopyalayıp çalıştırmalıyım.
<a href=https://github.com/monitise-mea/gerrit-dashboard-server/blob/master/Dockerfile>Dockerfile</a>’a bakarsak;</p><script type=application/javascript src=https://gist.github.com/tunix/b8e1e76ffbfd6a0f2408dea843411e1f.js></script><p>Gerrit Dashboard Server projesinden Docker imajı üretme işini Travis CI üstünde
<a href=https://travis-ci.org/monitise-mea/gerrit-dashboard-server>yapıyoruz</a>. Öncelikle imajın doğru şekilde üretildiğinden
emin olmak için kendi makinemizde kurulu olan Docker Engine üstünde deneyelim:</p><pre tabindex=0><code>docker build -t gerrit-dashboard-server:1.0.2 .
</code></pre><p>İşlem başarılı bir şekilde sonuçlandığında <code>docker images</code> komutunu verdiğinizde imajın oluşturulduğunu
doğrulayabilmelisiniz.</p><blockquote><p>İmajı dağıtıma çıkarmadan önce kullanılabilecek parametrelerle birlikte doğru şekilde çalıştığından emin olun.</p></blockquote><p>Oluşturduğunuz imajı başka bir makineye kopyalamak için 2 seçeneğiniz var:</p><ul><li>Docker Engine’den arşivlenmiş şekilde dışa aktarmak</li><li>Docker Store benzeri bir servise yüklemek</li></ul><p>Docker Engine’den arşivlenmiş şekilde dışa aktarmak için;</p><pre tabindex=0><code>docker save -o ~/Desktop/gerritdashboard-1.0.2.tar \
    gerrit-dashboard-server:1.0.2
</code></pre><p>komutunu kullanabilirsiniz. Oluşan tar dosyasını diğer makineye kopyaladıktan sonra yeniden içeri aktarım yapmak içinse;</p><pre tabindex=0><code>docker load -i gerritdashboard-1.0.2.tar
</code></pre><p>komutunu kullanabilirsiniz.</p><h3 id=docker-store--registry>Docker Store & Registry<a hidden class=anchor aria-hidden=true href=#docker-store--registry>#</a></h3><p>Docker imajlarını saklamanın en kolay yollarından birisi <a href=https://store.docker.com/>Docker Store</a>’a yüklemek.
Çoğunlukla baz imajları indirmek için en temel kaynak olarak kullandığımız <a href=https://hub.docker.com/>Docker Hub</a> (yeni
adıyla <a href=https://store.docker.com/>Docker Store</a>) aslında kendi imajlarımıza da ev sahipliği yapabilecek bir depo.
Genele açık imajlarınızı sınırsızca yükleyebileceğiniz servis, özel imajlarınız için 5 adede kadar ücretsiz olanak
sağlıyor. Sonrası içinse <a href=https://hub.docker.com/billing-plans/>ücretli üyeliklerden</a> birine geçilmesi gerekiyor.</p><p>Eğer oluşturduğunuz imajı herkese açık olarak yüklemenizde bir sakınca yoksa <a href=https://hub.docker.com/>Docker Hub</a>’a
ücretsiz olarak yükleyebilirsiniz. Bunun için öncelikle servise kayıt olmalısınız. Kayıt olduktan sonra kullanıcı
bilgilerinizle giriş yapın ve yeni bir Docker imaj deposu (repository) oluşturun. Bunun için tercih edebileceğiniz 2
yol var:</p><h4 id=manuel-depo>Manuel Depo<a hidden class=anchor aria-hidden=true href=#manuel-depo>#</a></h4><figure><img loading=lazy src=docker_hub_manuel_repo.png alt="Docker Hub’da manuel depo oluşturma formu"><figcaption><p>Docker Hub’da manuel depo oluşturma formu</p></figcaption></figure><p>Giriş yaptıktan sonra sağ üstteki Create menüsünden Create Repository’e basın. Formdaki alanları doldurduktan sonra
Create tuşuna basın. Şimdi imajı yükleme zamanı! 🤘🏻</p><p>Yükleme yapabilmek için bilgisayarınızdan Docker Hub’a giriş yapmak için;</p><pre tabindex=0><code>docker login
</code></pre><p>komutunu verin. E-posta adresinizi ve şifrenizi yazıp doğrulamadan geçtikten sonra ev dizininizdeki
<code>~/.docker/config.json</code> dosyasına ilgili servise ait giriş bilgileri (yetki kodu ve e-posta adresiniz) yazılacaktır.
Bu işlem, aynı servisi kullandığınız sürece tek seferliktir; tekrarlamanız gerekmez.</p><p>Yukardaki son <a href=#kendi-imajınızı-hazırlamak>örneğimizden</a> devam edelim. İmajımızı
<code>gerrit-dashboard-server:1.0.2</code> adıyla oluşturmuştuk. Docker Engine, imajı uzaktaki bir servise yükleyeceğimizde nereye
yükleyeceğini imajın adından <a href=https://alperkan.at/tr/2016/09/docker-serisi-2/#docker-push-registrygitlabcomtunixalperkanat105>buluyor</a>.
Bu nedenle imajı yeniden oluşturmamıza gerek yok; etiketleri kullanarak işlemi gerçekleştirebiliriz. Docker Hub servisi
için imajı etiketleyelim:</p><pre tabindex=0><code>docker tag gerrit-dashboard-server:1.0.2 docker.io/tunix/gerritdashboard-server:1.0.2
</code></pre><p>Artık imajı Docker Hub’a yükleyebiliriz:</p><pre tabindex=0><code>docker push docker.io/tunix/gerritdashboard-server:1.0.2
</code></pre><p>İşlem node imajını baz alıp üstüne sadece kendi katmanlarımızı eklediğimizden hızlıca tamamlanacaktır. Artık Docker
Engine yüklü olan herhangi bir makinede;</p><pre tabindex=0><code>docker pull docker.io/tunix/gerritdashboard-server:1.0.2
</code></pre><p>komutuyla imajı indirip kullanmaya başlayabilirsiniz.</p><h4 id=otomatik-depo>Otomatik Depo<a hidden class=anchor aria-hidden=true href=#otomatik-depo>#</a></h4><figure><img loading=lazy src=docker_hub_otomatik_depo.png alt="Docker Hub’da otomatik depo oluşturma formu"><figcaption><p>Docker Hub’da otomatik depo oluşturma formu</p></figcaption></figure><p>Giriş yaptıktan sonra sağ üstteki Create menüsünden Create Automated Build’a basın. Karşınıza yukarıdaki gibi GitHub
ya da Bitbucket arasında seçim yapmanız gereken bir ekran gelecek. Seçiminizi yaptığınızda ilgili servisin sitesine
gidip kod depolarınıza erişim hakkı vermeniz gerekecektir. Bu adımı gerçekleştirdikten sonra kod depolarınızı seçmeniz
için aşağıdaki gibi bir ekran göreceksiniz:</p><figure><img loading=lazy src=docker_hub_repo_secimi.png alt="GitHub kod depolarını listeleyen sayfadan istediğinizi seçin"><figcaption><p>GitHub kod depolarını listeleyen sayfadan istediğinizi seçin</p></figcaption></figure><p>Seçiminizi yaptığınızda karşınıza otomatik depo oluşturmanın son adımı olan form çıkacaktır; formu doldurup Create
tuşuna bastığınızda deponuz oluşturulacak ve ilk derleme işlemi için beklemeye başlayacaktır. Aslında kod deposu
seçimini yaptığınızda arkaplanda seçim yaptığınız depoya bir webhook (ağ kancası? 😂) eklenir. Kod deposuna yeni kod
parçacığı gönderdiğinizde Docker Hub’da otomatik olarak bir derlenme süreci tetiklenecek ve oluşturulan imajınız
sayfada yer alacaktır.</p><figure><img loading=lazy src=docker_hub_proje_sayfasi.png alt="GitHub’daki digitalocean-dyndns adlı projemin Docker imajları Docker Hub tarafından otomatik oluşturuluyor."><figcaption><p>GitHub’daki digitalocean-dyndns adlı projemin Docker imajları Docker Hub tarafından otomatik oluşturuluyor.</p></figcaption></figure><h4 id=docker-registry>Docker Registry<a hidden class=anchor aria-hidden=true href=#docker-registry>#</a></h4><p>Docker Hub bu servisi verirken arkaplanda <a href=https://github.com/docker/docker-registry>Docker Registry</a> (yeni adıyla
<a href=https://github.com/docker/distribution>Docker Distribution</a>) adı verilen açık kaynak kodlu bir yazılımı kullanıyor.
Eğer imajlarınızı yüklemek için bir registry’e para vermek istemiyorsanız kendi registry’nizi kurabilirsiniz. Ancak
böyle bir tercihte bulunacaksanız kurulum yapacağınız sunucunun yönetimini ve maliyetlerini de göz önünde bulundurun.
Öte yandan proje kodlarını git vb. bir SKS (sürüm kontrol sistemi) üstünde tuttuğunuz sürece geriye dönüp imajı yeniden
yaratmanız mümkün olabileceğinden riskiniz o kadar da yüksek değil. Yine de kodunuzun o anki hali değilse bile
bulunduğu ortamın ve bağımlılıkların sıkıntı çıkarabileceğini unutmayın. 🤔</p><h3 id=kendi-docker-registrynizi-kurun>Kendi Docker Registry&rsquo;nizi Kurun<a hidden class=anchor aria-hidden=true href=#kendi-docker-registrynizi-kurun>#</a></h3><p><a href="https://medium.com/u/f570294a852c?source=post_page-----a7c6c5f50851--------------------------------">Monitise MEA</a>’da
hibrid bir geliştirme ve test ortamımız var. Klasik şekilde bir VM üstüne kurulu Tomcat’e yüklenen sayısız projemiz
olduğu gibi, yeni projelerimizde Docker’ı kullanma seçeneğini her zaman göz önünde bulunduruyoruz. Gerçek ortamda
Docker’ı hiç kullanmayan projelerde dahi bazı durumlarda geliştirme ve test ortamı için Docker’ı tercih edebiliyoruz.
Dolayısıyla bu projelerin Docker imajlarını üretmemiz ve sunucular arasında taşımaya ihtiyacımız var ve Docker Registry
burada devreye giriyor.</p><p>Özetle, Docker Registry bir API’dan ve disk üstünde imaj katmanlarını yöneten bir sistemden oluşuyor. API v1 iken
<a href=https://github.com/docker/docker-registry>Docker Registry</a> adını taşırken, v2 ile birlikte
<a href=https://github.com/docker/distribution>Docker Distribution</a> adını aldı. Her ikisi de Docker Store’dan
<a href=https://store.docker.com/images/d93c7069-a612-4019-ade6-8c3b0a73acd9>indirilebilir durumda</a>. Kurmak için;</p><pre tabindex=0><code>docker run -d -p 5000:5000 --name registry registry:2
</code></pre><p>komutunu vermeniz yeterli. Bu durumda aşağıdaki öntanımlı değerler geçerli olur:</p><ul><li>İmajlarınız container içindeki <code>/var/lib/registry</code> dizini altına yazılır. Öntanımlı olarak filesystem sürücüsü
kullanılır. Alternatifler <a href=https://docs.docker.com/registry/storage-drivers/>şurada</a>.</li><li>Registry’nize, herhangi bir SSL sertifikasına sahip olmadığından, HTTP üstünden ulaşırsınız.</li><li>Registry’niz herkesin yüklemesine ve indirmesine açık şekilde çalışır; kullanıcıların önce giriş yapmaları gerekmez.
Kullandığınız ağın dışarıya açık olmaması durumunda bu şekilde de çalışabilirsiniz.</li></ul><p>Registry kurulumuyla ilgili en güncel bilgiyi <a href=https://docs.docker.com/registry/deploying/>şuradan</a> bulabilirsiniz.
Benim tavsiyem; registry için ev sahibi makineye ek disk vermeniz ve container’daki <code>/var/lib/registry</code> dizinini ev
sahibi makinedeki <code>/registry</code> dizinine bağlamanız yönünde. Ayrıca registry’i kullanan tüm makinelerde ek ayar
(<code>--insecure-registry</code>) yapmamak için sunucuya geçerli bir sertifika kurmanızda fayda var.
<a href=https://letsencrypt.org/>LetsEncrypt</a> gibi güzelliklerin olduğu günümüzde yapmazsanız ayıp! 😉 Tabii sertifika işini
registry’nin önüne bir HTTP sunucusu (<a href=https://nginx.org/>nginx</a>, <a href=http://httpd.apache.org/>Apache</a> vb.) koyarak da
çözebilirsiniz. Hatta HTTP sunucusu yerine <a href=https://hub.docker.com/r/yajo/https-proxy/>https-proxy</a>’i de
kullanabilirsiniz.</p><p>Son durumda registry kurulumu için aşağıdaki gibi bir komuta ihtiyacınız var:</p><pre tabindex=0><code>docker run -d --name registry \
    -p 5000:5000 \
    --restart=always \
    -v /registry:/var/lib/registry \
    registry:2
</code></pre><p><a href=https://hub.docker.com/r/yajo/https-proxy/>https-proxy</a> kullanmak isteyenlere bonus olarak örnek komutu ekleyeyim:</p><pre tabindex=0><code>docker run -d --name registry-ssl \
    -e KEY=”$(cat registry.key)” \
    -e CERT=”$(cat registry.crt)” \
    -p 443:443 \
    -e PORT=5000 \
    --restart=always \
    --link registry:www \
    yajo/https-proxy
</code></pre><blockquote><p>registry container’ını yaratırken kullandığınız ismin, https-proxy’i yaratırken kullandığınız komuttaki &ndash;link
bölümündeki registry ismiyle aynı olduğundan emin olun.</p></blockquote><p>Diyelim ki; registry’inize ulaştığınız adres <code>docker.example.com</code> olsun. Bu durumda imajlarınızı buraya yüklemek için
<code>docker.example.com/tunix/alperkan.at:1.0.2</code> gibi isimlendirmelisiniz. <code>docker push</code> komutuyla imajınızı yüklerken,
Docker Engine otomatik olarak HTTPS protokolünü tercih edecektir. Bu nedenle SSL adımını atladıysanız ve kendi
makinenizden yükleme yapıyorsanız Docker Engine ayarlarında yeni registry’inizi &ldquo;Insecure Registries&rdquo; bölümünden
ekleyin. Linux’da bu arayüz geliyor mu emin değilim ama <a href=https://docs.docker.com/registry/insecure/>şuradaki adımları</a>
takip edebilirsiniz.</p><figure><img loading=lazy src=docker_for_mac_advanced_tab.png></figure><hr><p>Bu bölümünün de sonuna geldik. Bir sonraki bölümde Docker Compose’dan ve özellikle birden fazla parçaya ihtiyaç duyan
projelerinizi Docker ile nasıl kolayca ayağa kaldırabileceğinizden bahsedeceğim.</p><p>Gidişâta göre bu planda zaman zaman değişiklikler yapacak olsam da serinin tüm bölümlerinin planına
<a href=https://www.evernote.com/l/AB7CctYtJkpMUJsae1_3FgzIXgMY5MvFQhU>şuradan</a> ulaşabilirsiniz.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://alperkan.at/tr/tags/yaz%C4%B1l%C4%B1m/>yazılım</a></li><li><a href=https://alperkan.at/tr/tags/docker/>docker</a></li><li><a href=https://alperkan.at/tr/tags/docker-serisi/>docker serisi</a></li><li><a href=https://alperkan.at/tr/tags/container/>container</a></li><li><a href=https://alperkan.at/tr/tags/sanalla%C5%9Ft%C4%B1rma/>sanallaştırma</a></li><li><a href=https://alperkan.at/tr/tags/linux/>linux</a></li><li><a href=https://alperkan.at/tr/tags/devops/>devops</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://alperkan.at/tr/>Alper Kanat</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById("menu");menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>