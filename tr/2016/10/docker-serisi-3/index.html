<!doctype html><html lang=tr dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Docker Serisi #3 -- Docker Engine BÃ¶lÃ¼m 2 | Alper Kanat</title><meta name=keywords content="yazÄ±lÄ±m,docker,docker serisi,container,sanallaÅŸtÄ±rma,linux,devops"><meta name=description content="Docker Serisiâ€™nin 3. bÃ¶lÃ¼mÃ¼ne hoÅŸgeldiniz! Ä°lk bÃ¶lÃ¼mde sanallaÅŸtÄ±rmanÄ±n ne olduÄŸundan, container teknolojisinden ve temel Docker kavramlarÄ±ndan; ikinci bÃ¶lÃ¼mde Docker Engine ve Docker komutlarÄ±ndan bahsetmiÅŸtim. Bu bÃ¶lÃ¼mdeyse Ã¶zetle ÅŸu konulara deÄŸineceÄŸim:
KalÄ±cÄ± Veri Depolama Ã‡evresel DeÄŸiÅŸkenler BaÄŸlantÄ± NoktalarÄ± Dockerfile Kendi Ä°majÄ±nÄ±zÄ± HazÄ±rlamak Docker Store & Registry Kendi Docker Registryâ€™nizi Kurun HÄ±zlÄ±ca baÅŸlayalÄ±m! ğŸ™‚
KalÄ±cÄ± Veri Depolama Ä°kinci bÃ¶lÃ¼mÃ¼n docker run komutuyla ilgili olan kÄ±smÄ±nda containerâ€™lara dÄ±ÅŸarÄ±dan dosya ve dizin baÄŸlanabileceÄŸinden bahsetmiÅŸtim. Normalde, Ã¶lÃ§eklenebilirliÄŸin Ã¶n planda olduÄŸu gerÃ§ek ortam containerâ€™larÄ± dÄ±ÅŸarÄ±dan baÄŸÄ±msÄ±z Ã§alÄ±ÅŸabilecek ÅŸekilde tasarlanmalÄ±dÄ±r."><meta name=author content><link rel=canonical href=https://alperkan.at/tr/2016/10/docker-serisi-3/><link crossorigin=anonymous href=/assets/css/stylesheet.min.2d6dbfc6e0f8a1db1c9d082a76dc11d094328cf63f247bbc2421dfaa7f2bb170.css integrity="sha256-LW2/xuD4odscnQgqdtwR0JQyjPY/JHu8JCHfqn8rsXA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://alperkan.at/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://alperkan.at/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://alperkan.at/favicon-32x32.png><link rel=apple-touch-icon href=https://alperkan.at/apple-touch-icon.png><link rel=mask-icon href=https://alperkan.at/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.102.3"><link rel=alternate hreflang=tr href=https://alperkan.at/tr/2016/10/docker-serisi-3/><script async src="https://www.googletagmanager.com/gtag/js?id=G-SDT9Y68PM3"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-SDT9Y68PM3",{anonymize_ip:!1})}</script><meta property="og:title" content="Docker Serisi #3 -- Docker Engine BÃ¶lÃ¼m 2"><meta property="og:description" content="Docker Serisiâ€™nin 3. bÃ¶lÃ¼mÃ¼ne hoÅŸgeldiniz! Ä°lk bÃ¶lÃ¼mde sanallaÅŸtÄ±rmanÄ±n ne olduÄŸundan, container teknolojisinden ve temel Docker kavramlarÄ±ndan; ikinci bÃ¶lÃ¼mde Docker Engine ve Docker komutlarÄ±ndan bahsetmiÅŸtim. Bu bÃ¶lÃ¼mdeyse Ã¶zetle ÅŸu konulara deÄŸineceÄŸim:
KalÄ±cÄ± Veri Depolama Ã‡evresel DeÄŸiÅŸkenler BaÄŸlantÄ± NoktalarÄ± Dockerfile Kendi Ä°majÄ±nÄ±zÄ± HazÄ±rlamak Docker Store & Registry Kendi Docker Registryâ€™nizi Kurun HÄ±zlÄ±ca baÅŸlayalÄ±m! ğŸ™‚
KalÄ±cÄ± Veri Depolama Ä°kinci bÃ¶lÃ¼mÃ¼n docker run komutuyla ilgili olan kÄ±smÄ±nda containerâ€™lara dÄ±ÅŸarÄ±dan dosya ve dizin baÄŸlanabileceÄŸinden bahsetmiÅŸtim. Normalde, Ã¶lÃ§eklenebilirliÄŸin Ã¶n planda olduÄŸu gerÃ§ek ortam containerâ€™larÄ± dÄ±ÅŸarÄ±dan baÄŸÄ±msÄ±z Ã§alÄ±ÅŸabilecek ÅŸekilde tasarlanmalÄ±dÄ±r."><meta property="og:type" content="article"><meta property="og:url" content="https://alperkan.at/tr/2016/10/docker-serisi-3/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2016-10-13T00:00:00+00:00"><meta property="article:modified_time" content="2021-04-25T17:47:11+03:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Docker Serisi #3 -- Docker Engine BÃ¶lÃ¼m 2"><meta name=twitter:description content="Docker Serisiâ€™nin 3. bÃ¶lÃ¼mÃ¼ne hoÅŸgeldiniz! Ä°lk bÃ¶lÃ¼mde sanallaÅŸtÄ±rmanÄ±n ne olduÄŸundan, container teknolojisinden ve temel Docker kavramlarÄ±ndan; ikinci bÃ¶lÃ¼mde Docker Engine ve Docker komutlarÄ±ndan bahsetmiÅŸtim. Bu bÃ¶lÃ¼mdeyse Ã¶zetle ÅŸu konulara deÄŸineceÄŸim:
KalÄ±cÄ± Veri Depolama Ã‡evresel DeÄŸiÅŸkenler BaÄŸlantÄ± NoktalarÄ± Dockerfile Kendi Ä°majÄ±nÄ±zÄ± HazÄ±rlamak Docker Store & Registry Kendi Docker Registryâ€™nizi Kurun HÄ±zlÄ±ca baÅŸlayalÄ±m! ğŸ™‚
KalÄ±cÄ± Veri Depolama Ä°kinci bÃ¶lÃ¼mÃ¼n docker run komutuyla ilgili olan kÄ±smÄ±nda containerâ€™lara dÄ±ÅŸarÄ±dan dosya ve dizin baÄŸlanabileceÄŸinden bahsetmiÅŸtim. Normalde, Ã¶lÃ§eklenebilirliÄŸin Ã¶n planda olduÄŸu gerÃ§ek ortam containerâ€™larÄ± dÄ±ÅŸarÄ±dan baÄŸÄ±msÄ±z Ã§alÄ±ÅŸabilecek ÅŸekilde tasarlanmalÄ±dÄ±r."><script type=application/ld+json>
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://alperkan.at/tr/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Docker Serisi #3 -- Docker Engine BÃ¶lÃ¼m 2",
      "item": "https://alperkan.at/tr/2016/10/docker-serisi-3/"
    }
  ]
}
</script><script type=application/ld+json>
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Docker Serisi #3 -- Docker Engine BÃ¶lÃ¼m 2",
  "name": "Docker Serisi #3 -- Docker Engine BÃ¶lÃ¼m 2",
  "description": "Docker Serisiâ€™nin 3. bÃ¶lÃ¼mÃ¼ne hoÅŸgeldiniz! Ä°lk bÃ¶lÃ¼mde sanallaÅŸtÄ±rmanÄ±n ne olduÄŸundan, container teknolojisinden ve temel Docker kavramlarÄ±ndan; ikinci bÃ¶lÃ¼mde Docker Engine ve Docker komutlarÄ±ndan bahsetmiÅŸtim. Bu bÃ¶lÃ¼mdeyse Ã¶zetle ÅŸu konulara deÄŸineceÄŸim:\nKalÄ±cÄ± Veri Depolama Ã‡evresel DeÄŸiÅŸkenler BaÄŸlantÄ± NoktalarÄ± Dockerfile Kendi Ä°majÄ±nÄ±zÄ± HazÄ±rlamak Docker Store \u0026amp; Registry Kendi Docker Registryâ€™nizi Kurun HÄ±zlÄ±ca baÅŸlayalÄ±m! ğŸ™‚\nKalÄ±cÄ± Veri Depolama Ä°kinci bÃ¶lÃ¼mÃ¼n docker run komutuyla ilgili olan kÄ±smÄ±nda containerâ€™lara dÄ±ÅŸarÄ±dan dosya ve dizin baÄŸlanabileceÄŸinden bahsetmiÅŸtim. Normalde, Ã¶lÃ§eklenebilirliÄŸin Ã¶n planda olduÄŸu gerÃ§ek ortam containerâ€™larÄ± dÄ±ÅŸarÄ±dan baÄŸÄ±msÄ±z Ã§alÄ±ÅŸabilecek ÅŸekilde tasarlanmalÄ±dÄ±r.",
  "keywords": [
    "yazÄ±lÄ±m", "docker", "docker serisi", "container", "sanallaÅŸtÄ±rma", "linux", "devops"
  ],
  "articleBody": "Docker Serisiâ€™nin 3. bÃ¶lÃ¼mÃ¼ne hoÅŸgeldiniz! Ä°lk bÃ¶lÃ¼mde sanallaÅŸtÄ±rmanÄ±n ne olduÄŸundan, container teknolojisinden ve temel Docker kavramlarÄ±ndan; ikinci bÃ¶lÃ¼mde Docker Engine ve Docker komutlarÄ±ndan bahsetmiÅŸtim. Bu bÃ¶lÃ¼mdeyse Ã¶zetle ÅŸu konulara deÄŸineceÄŸim:\nKalÄ±cÄ± Veri Depolama Ã‡evresel DeÄŸiÅŸkenler BaÄŸlantÄ± NoktalarÄ± Dockerfile Kendi Ä°majÄ±nÄ±zÄ± HazÄ±rlamak Docker Store \u0026 Registry Kendi Docker Registryâ€™nizi Kurun HÄ±zlÄ±ca baÅŸlayalÄ±m! ğŸ™‚\nKalÄ±cÄ± Veri Depolama Ä°kinci bÃ¶lÃ¼mÃ¼n docker run komutuyla ilgili olan kÄ±smÄ±nda containerâ€™lara dÄ±ÅŸarÄ±dan dosya ve dizin baÄŸlanabileceÄŸinden bahsetmiÅŸtim. Normalde, Ã¶lÃ§eklenebilirliÄŸin Ã¶n planda olduÄŸu gerÃ§ek ortam containerâ€™larÄ± dÄ±ÅŸarÄ±dan baÄŸÄ±msÄ±z Ã§alÄ±ÅŸabilecek ÅŸekilde tasarlanmalÄ±dÄ±r. AslÄ±nda bakarsanÄ±z Ã¶lÃ§eklenebilirliÄŸin maksimize edilmesi iÃ§in uygulamanÄ±zÄ±n, 12 FaktÃ¶r prensibine uygun tasarlanmÄ±ÅŸ olmasÄ± gerekir. Bu prensiplere uyarak Ã¶rneÄŸin uygulamanÄ±zdan N tane container baÅŸlatarak Ã¶lÃ§eklenebilirliÄŸi rahatlÄ±kla saÄŸlayabilirsiniz.\nÃ–lÃ§eklenebilirliÄŸin Ã§ok sorun olmadÄ±ÄŸÄ± durumlarda ya da geliÅŸtirme/test ortamlarÄ±nda dosya/dizin baÄŸlamak size bÃ¼yÃ¼k kolaylÄ±k saÄŸlar. Ã–rneÄŸin uygulama kayÄ±tlarÄ±nÄ±zÄ± (log) merkezi bir servis yerine yerel dosya sistemine yazÄ±yorsanÄ±z, ilgili dizini ev sahibi makineye baÄŸlamak akÄ±lcÄ± olacaktÄ±r. Ya da uygulamalarÄ±nÄ±zÄ± Tomcatâ€™e dizin aÃ§arak yÃ¼klÃ¼yorsanÄ±z webapps dizinini ev sahibi makineye baÄŸlamak isteyebilirsiniz.\nContainerâ€™larda kalÄ±cÄ± veri depolama (persistence) sÃ¶z konusu olduÄŸunda 3 tip depolamadan bahsetmek mÃ¼mkÃ¼n:\nEv sahibi makineden dizin/dosya baÄŸlayarak depolamak Bu yÃ¶ntemde ev sahibi makineyi paylaÅŸÄ±mlÄ± dizin gibi dÃ¼ÅŸÃ¼nebiliriz. Bir kaÃ§ Ã¶rnek senaryo sayarsam:\nnginx kurarken /etc/nginx/nginx.confâ€™u ev sahibi makineden baÄŸlayarak Ã¼zerinde deÄŸiÅŸiklik yapmayÄ± kolaylaÅŸtÄ±rmak nginx imajÄ±nda hiÃ§ bir deÄŸiÅŸiklik yapmaksÄ±zÄ±n ev sahibi makinede tuttuÄŸum statik web uygulamamÄ±n dizinini /var/www/html dizinine baÄŸlayarak doÄŸrudan sunmak Ev sahibi makinede tuttuÄŸum, PHP ile geliÅŸtirdiÄŸim kod tabanÄ±mÄ± container ile paylaÅŸarak yaptÄ±ÄŸÄ±m deÄŸiÅŸikliklerin sonucunu container Ã¼stÃ¼nden anÄ±nda gÃ¶rmek Ev sahibi makinede bulunan bir dizindeki tÃ¼m dosyalarÄ±, containerâ€™Ä±n iÃ§inde Ã§alÄ±ÅŸacak bir program ile iÅŸleyip aynÄ± dizine yeniden yazmak Ev sahibi makinede Ã§alÄ±ÅŸan Docker Engineâ€™in Ã§alÄ±ÅŸma dizinini, containerâ€™a baÄŸlayarak Docker Engineâ€™de bazÄ± iÅŸlemler yapmak (Ã¶r: docker-cleanup) Peki dosya ya da dizinleri nasÄ±l baÄŸlÄ±yoruz? YukarÄ±daki bir kaÃ§ Ã¶rneÄŸi gerÃ§ekleyelim:\nDÄ±ÅŸarÄ±dan /etc/nginx/nginx.confâ€™u baÄŸlamak:\ndocker run -d --name nginx1 -v /home/alper/nginx/nginx.conf:/etc/nginx/nginx.conf -p 8000:80 nginx DÄ±ÅŸarÄ±dan statik web uygulamasÄ±nÄ±n dizinini baÄŸlamak:\ndocker run -d --name nginx2 -v /home/alper/web:/var/www/html -p 8001:80 nginx DÄ±ÅŸarÄ±dan dizin baÄŸlayÄ±p iÃ§indeki dosyalarÄ± iÅŸlemek:\ndocker run --rm -v /home/alper/test:/test ubuntu sed â€˜/kanat/dâ€™ /test/deneme.txt DepolayÄ±cÄ± containerâ€™lar kullanmak KalÄ±cÄ± veri depolamanÄ±n Dockerâ€™ca yolu, depolayÄ±cÄ± containerâ€™lar kullanmaktan geÃ§iyor. DepolayÄ±cÄ± containerâ€™larÄ±n avantajlarÄ± kabaca ÅŸÃ¶yle:\nÄ°lgili alanÄ± birden fazla container ile paylaÅŸabilirsiniz. Bir containerâ€™a birden fazla depolayÄ±cÄ± container baÄŸlayabilirsiniz. DepolayÄ±cÄ± containerâ€™lar, beraber Ã§alÄ±ÅŸtÄ±klarÄ± containerâ€™lar Ã¶lse dahi silinmez; tekrar tekrar kullanÄ±labilirler. DepolayÄ±cÄ± container yaratmak iÃ§in;\ndocker create -v /dbdata --name dbstore training/postgres /bin/true DepolayÄ±cÄ± containerâ€™Ä± baÄŸlamak iÃ§in;\ndocker run -d --volumes-from dbstore --name db1 training/postgres yazabilirsiniz. Bu sayede db1 adÄ±ndaki containerâ€™Ä±nÄ±zÄ±n iÃ§indeki /dbdata dizini, aslÄ±nda dbstore containerâ€™Ä±ndan baÄŸlanmÄ±ÅŸ olacaktÄ±r. Diyelim ki; disk alanÄ±nÄ± yedeklemek istiyoruz. Yeni bir container ile aynÄ± depolayÄ±cÄ± containerâ€™Ä± baÄŸlayarak bu iÅŸlemi gerÃ§ekleÅŸtirebiliriz:\ndocker run --rm --volumes-from dbstore -v $(pwd):/backup ubuntu tar cvf /backup/backup.tar /dbdata Bu komutun yaptÄ±klarÄ±nÄ± kÄ±saca Ã¶zetlersek;\nÃ‡alÄ±ÅŸtÄ±ktan sonra silinecek ÅŸekilde, Ubuntu imajÄ±ndan yeni bir container yarat (docker run --rm) Bu containerâ€™a dbstore adlÄ± depolayÄ±cÄ± containerâ€™Ä±ndan dÄ±ÅŸarÄ± aÃ§Ä±lan dizinleri baÄŸla (--volumes-from dbstore) Ev sahibi makine Ã¼stÃ¼nde bulunduÄŸum dizini, container iÃ§erisindeki /backup dizinine baÄŸla. (-v $(pwd):/backup) Container Ã¼stÃ¼ndeki /dbdata dizinini sÄ±kÄ±ÅŸtÄ±rarak ev sahibi makine Ã¼stÃ¼nde /backup/backup.tar olarak kaydet. PaylaÅŸÄ±mlÄ± Disk AlanlarÄ± Kullanmak Docker, 1.8.0 sÃ¼rÃ¼mÃ¼nden itibaren disk alanlarÄ± iÃ§in sÃ¼rÃ¼cÃ¼ desteÄŸiyle beraber geliyor. Az sonra bahsedeceÄŸim komutlara ek olarak; Azure, Google Compute Engine, NFS vb. sÃ¼rÃ¼cÃ¼leri parametre olarak geÃ§erek (Ã¶r: --volume-driver=flocker) farklÄ± servislerden disk alanlarÄ±nÄ± da containerâ€™larÄ±nÄ±za baÄŸlayabilirsiniz. Herhangi bir sÃ¼rÃ¼cÃ¼ belirtmezseniz Ã¶ntanÄ±mlÄ± olan yerel disk sÃ¼rÃ¼cÃ¼sÃ¼ (--volume-driver=local) kullanÄ±lÄ±r ve disk alanÄ± makinenizde oluÅŸturulur.\nYerel disk alanÄ± yaratmak iÃ§in:\ndocker volume create --name=shared-disk [YÃ¼kledikten sonra] flocker sÃ¼rÃ¼cÃ¼sÃ¼ ile yaratmak iÃ§in:\ndocker volume create -d flocker -o size=20GB --name=shared-disk OluÅŸturduÄŸunuz disk alanÄ±nÄ± containerâ€™daki bir bÃ¶lÃ¼me baÄŸlamak iÃ§in:\ndocker run -d --name=t1 -v shared-disk:/usr/local/tomcat/webapps -P tomcat docker run -d --name=t2 -v shared-disk:/usr/local/tomcat/webapps -P tomcat YukarÄ±daki ÅŸekilde 2 tane Tomcat sunucusu baÅŸlatÄ±p aynÄ± disk alanÄ±nÄ± ikisine birden baÄŸlayabiliyoruz.\nÃ‡evresel DeÄŸiÅŸkenler Ä°ster web uygulamasÄ± olsun, ister bir API uygulamasÄ±; bir uygulamanÄ±n en Ã¶nemli kÄ±sÄ±mlarÄ±ndan biri yapÄ±landÄ±rma kÄ±smÄ±dÄ±r. Bazen bu yapÄ±landÄ±rma, uygulamada kullanÄ±lan 3. parti servislerin eriÅŸim bilgileridir, bazense uygulamanÄ±n nasÄ±l davranacaÄŸÄ±nÄ± belirleyen kritik roldeki bir anahtardÄ±r. YalnÄ±zca bir anahtarÄ±n deÄŸerini deÄŸiÅŸtirerek gerÃ§ek bir veritabanÄ± yerine Ã¶rnek verilerle Ã§alÄ±ÅŸmasÄ±nÄ± saÄŸlayabilir ya da uygulama iÃ§indeki bir Ã¶zelliÄŸi komple aÃ§Ä±p kapatabilirsiniz.\nEski tip yazÄ±lÄ±m paketleme yÃ¶ntemlerinde; uygulama iÃ§erisinde tutulan yapÄ±landÄ±rma dosyalarÄ±nÄ±n deÄŸerleriyle oynayÄ±p birden fazla paket Ã§Ä±karmak oldukÃ§a yaygÄ±n. Dockerâ€™da ise imajÄ±nÄ±zÄ± gerÃ§ek ortama gÃ¶re hazÄ±rlayÄ±p dÄ±ÅŸarÄ±dan vereceÄŸiniz Ã§evresel deÄŸiÅŸkenlerle her ÅŸeyi yÃ¶netebilirsiniz.\nTanÄ±mlayacaÄŸÄ±nÄ±z Ã§evresel deÄŸiÅŸkenler, container iÃ§erisinde iÅŸletim sistemi seviyesinde ve tÃ¼m uygulamalarda eriÅŸilebilir durumda olacaktÄ±r. Bu sayede yapÄ±landÄ±rma dosyalarÄ±nda ya da Ã§alÄ±ÅŸtÄ±rma betiklerinde Ã§evresel deÄŸiÅŸkenlerinizi kullanabilirsiniz. Bu sayede son derece esnek imajlar yaratmanÄ±z mÃ¼mkÃ¼n.\nÃ‡evresel deÄŸiÅŸkenlerle ilgili serinin ilerleyen bÃ¶lÃ¼mlerinde gerÃ§ekÃ§i Ã¶rnekler vereceÄŸim iÃ§in ÅŸimdilik Tomcat ve MySQL Ã¶zelinde 2 Ã¶rnekle bu kÄ±smÄ± noktalÄ±yorum:\nTomcat Manager UygulamasÄ± Åifresini Belirlemek docker run -d -p 8080:8080 -e TOMCAT_PASS=â€mypassâ€ tutum/tomcat Burada tutumâ€™un imajÄ±nÄ± kullanma sebebim; orjinal Tomcat imajlarÄ±nda Ã§evresel deÄŸiÅŸkenler ile ÅŸifre belirleme Ã¶zelliÄŸinin bulunmuyor oluÅŸundan kaynaklanÄ±yor.\nMySQL YÃ¶netici Åifresini Belirlemek docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql Docker Hubâ€™dan (yeni adÄ±yla Docker Store) indirdiÄŸiniz imajlarÄ±n hangi Ã§evresel deÄŸiÅŸkenleri kullandÄ±ÄŸÄ±nÄ± anlamak iÃ§in ilgili sayfalarÄ±na bakabilirsiniz. Maalesef bazÄ± imajlarda bu detaylar yeterince belgelendirilmediÄŸi iÃ§in imajlarÄ±n kaynak kodlarÄ±ndaki Dockerfile dosyalarÄ±nÄ± incelemeniz gerekebilir.\nBaÄŸlantÄ± NoktalarÄ± BaÄŸlantÄ± noktalarÄ± (port) dÄ±ÅŸ dÃ¼nya ile containerâ€™larÄ±nÄ±zÄ±n iletiÅŸimini saÄŸlar. Bir web uygulamasÄ± geliÅŸtirdiÄŸimizi varsayarsak, containerâ€™daki 80. baÄŸlantÄ± noktasÄ±nÄ± ev sahibi makinedeki herhangi bir baÄŸlantÄ± noktasÄ±na baÄŸlamadan uygulamamÄ±za eriÅŸemeyiz.\nDocker, Ã§alÄ±ÅŸma zamanÄ±nda Ã¶zellikle belirtmediÄŸiniz sÃ¼rece, Ã¶ntanÄ±mlÄ± olarak herhangi bir baÄŸlantÄ± noktasÄ±nÄ± dÄ±ÅŸarÄ±ya aÃ§mayacaktÄ±r. Ä°maj hazÄ±rlanÄ±rken baÄŸlantÄ± noktalarÄ±nÄ±n tanÄ±mlarÄ± da Dockerfile iÃ§ine yazÄ±lÄ±r. Ancak yine de containerâ€™Ä± Ã§alÄ±ÅŸtÄ±rÄ±rken, -p ya da -P ile ev sahibi makineye baÄŸlamazsanÄ±z dÄ±ÅŸarÄ±dan eriÅŸilmez olacaktÄ±r.\nContainerâ€™Ä±n tanÄ±mladÄ±ÄŸÄ± baÄŸlantÄ± noktalarÄ±nÄ± docker ps komutuyla gÃ¶rebilirsiniz: 0.0.0.0:80-\u003e80/tcp, 443/tcp Bu Ã§Ä±ktÄ±ya baktÄ±ÄŸÄ±mÄ±zda 80. baÄŸlantÄ± noktasÄ±nÄ±n ev sahibi makinedeki tÃ¼m aÄŸlara baÄŸlandÄ±ÄŸÄ±nÄ±, 443. baÄŸlantÄ± noktasÄ±nÄ±n ise baÄŸlanmadÄ±ÄŸÄ±nÄ± gÃ¶rÃ¼yoruz. Sadece baÄŸlanmÄ±ÅŸ olanlarÄ± gÃ¶rmek iÃ§in docker port container_adi (Ã¶rnek: docker port nginx) komutunu da kullanabiliriz.\n80 (HTTP) ve 443 (HTTPS) BaÄŸlantÄ± NoktalarÄ±nÄ± BaÄŸlayalÄ±m AÅŸaÄŸÄ±daki komutla ev sahibi makinenin 80. ve 443. baÄŸlantÄ± noktalarÄ±nÄ±, containerâ€™daki 80. ve 443. baÄŸlantÄ± noktalarÄ±na baÄŸlayabiliriz:\ndocker run -d --name nginx -p 80:80 -p 443:443 nginx BaÄŸlantÄ± NoktalarÄ±nÄ± Rastgele BaÄŸlayalÄ±m Java ile yazÄ±lmÄ±ÅŸ bir Spring Boot uygulamanÄ±z olduÄŸunu varsayalÄ±m. Spring Bootâ€™un avantajlarÄ±ndan biri, Tomcatâ€™i uygulamayla birlikte JAR olarak paketleyebiliyorsunuz. Åimdi uygulamamÄ±zÄ± Docker imajÄ± haline getirdiÄŸimizi ve yukarÄ±daki yÃ¶ntemle baÅŸlattÄ±ÄŸÄ±mÄ±zÄ± dÃ¼ÅŸÃ¼nelim. AynÄ± ev sahibi makine Ã¼stÃ¼nde bir baÄŸlantÄ± noktasÄ±nÄ± yalnÄ±zca bir container kullanabilir. Bu nedenle yeniden yukarÄ±daki yÃ¶ntemi kullanmak isterseniz yalnÄ±zca -p 81:80 -p 444:443 yazarak baÅŸlatabilirsiniz.\nÃ–lÃ§eklendirilebilirliÄŸin Ã¶nemli olduÄŸu durumlarda baÄŸlantÄ± noktasÄ±nÄ± sÃ¼rekli elle artÄ±rarak yeni container aÃ§mak pek kabul edilebilir bir yÃ¶ntem deÄŸil. Bu nedenle doÄŸru olan yÃ¶ntem -P parametresini kullanarak containerâ€™da tanÄ±mlanmÄ±ÅŸ tÃ¼m baÄŸlantÄ± noktalarÄ±nÄ±n ev sahibi makinedeki rastgele baÄŸlantÄ± noktalarÄ±na atanmasÄ±nÄ± saÄŸlamaktÄ±r. Serinin ileriki bÃ¶lÃ¼mlerinden â€œGÃ¼nlÃ¼k KullanÄ±m BÃ¶lÃ¼m 1â€ iÃ§erisinde bu yÃ¶ntemden daha detaylÄ± bahsedeceÄŸim.\nRastgele baÄŸlantÄ± noktasÄ± atamasÄ± iÃ§in aÅŸaÄŸÄ±daki komutu kullanabilirsiniz:\ndocker run -d --name nginx -P nginx Dockerfile Dockerfile ile ilgili en detaylÄ± ve gÃ¼ncel bilgiyi kendi sitesinde bulabilirsiniz. Bu kÄ±sÄ±mda kÄ±saca Dockerfileâ€™Ä± neden ve nasÄ±l kullanmanÄ±z gerektiÄŸini anlatmaya Ã§alÄ±ÅŸacaÄŸÄ±m. Dockerfile, Ã¶zetle bir Docker imajÄ±nÄ± tarif eder. Hangi imajÄ± baz alacaÄŸÄ±mÄ±zÄ±, baz aldÄ±ÄŸÄ±mÄ±z imajÄ±n Ã¼stÃ¼nde Ã§alÄ±ÅŸtÄ±racaÄŸÄ±mÄ±z komutlarÄ±, oluÅŸturacaÄŸÄ±mÄ±z dizinleri, dÄ±ÅŸ kullanÄ±ma aÃ§Ä±labilecek Ã§evresel deÄŸiÅŸkenleri, baÄŸlantÄ± noktalarÄ±nÄ± ve disk alanlarÄ±nÄ± bu dosyada belirtiyoruz. Yine bir Ã¶rnek Ã¼stÃ¼nden ilerleyelim:\nHer Dockerfile, FROM satÄ±rÄ±yla baÅŸlar. Ä°majÄ±mÄ±zÄ±, node:6.2-slim imajÄ±nÄ± baz alarak yaratacaÄŸÄ±z. -slimâ€™i imajÄ± mÃ¼mkÃ¼n olduÄŸunca kÃ¼Ã§Ã¼ltmek amacÄ±yla kullanÄ±yorum. Ä°majÄ± ilk inÅŸa ettiÄŸimiz noktada ne kadar kÃ¼Ã§Ã¼kten baÅŸlatabilirsek o kadar iyi. Bu nedenle Alpine Linux, *-slim vb. seÃ§enekleriniz varsa mutlaka kullanÄ±n. Ã–rneÄŸin Javaâ€™yla yazÄ±lmÄ±ÅŸ uygulamanÄ±zÄ± Debian ya da Ubuntu imajÄ±nÄ± baz alÄ±p Ã¼stÃ¼ne Java kurarak oluÅŸturmak yerine, doÄŸrudan java imajlarÄ±nÄ± tercih etmelisiniz.\nZorunlu olmasa da, Docker Store vb. yerlerde sorgulanabilmesi ve sorumlunun aÃ§Ä±kÃ§a gÃ¶rÃ¼lebilmesi aÃ§Ä±sÄ±ndan MAINTAINER satÄ±rÄ±nÄ± kullanmanÄ±z iyi olur.\nADD komutuyla, bulunduÄŸum dizini containerâ€™Ä±n /srv dizinine kopyalÄ±yorum. UygulamamÄ± bu dizinde tutuyor olacaÄŸÄ±m. Bu tercih tamamen size kalmÄ±ÅŸ. Ä°sterseniz /app vb. bir dizin de kullanabilirsiniz. Ya da Tomcat imajÄ±nÄ± baz alÄ±yorsanÄ±z doÄŸrudan uygulamanÄ±zÄ± /usr/share/tomcat/webapps gibi bir dizin altÄ±na da kopyalayabilirsiniz. Bir sonraki satÄ±rda (WORKDIR) ise bundan sonraki komutlarÄ±n Ã§alÄ±ÅŸtÄ±rÄ±lacaÄŸÄ± dizini /srv olarak belirtiyorum.\nDockerfileâ€™daki her satÄ±r diÄŸer komutlardan baÄŸÄ±msÄ±z Ã§alÄ±ÅŸÄ±r. WORKDIR /srv yerine cd /srv yazarsanÄ±z bu sonraki komutlarÄ±n yine / dizininde Ã§alÄ±ÅŸmasÄ±na sebep olacaktÄ±r.\nSerinin ilk bÃ¶lÃ¼mÃ¼ndeki â€œÄ°maj ne demek?â€ kÄ±smÄ±nda bahsettiÄŸim gibi, Docker imajlarÄ± katmanlardan oluÅŸur. Dockerfileâ€™da yazdÄ±ÄŸÄ±nÄ±z, imaja bir ÅŸey ekleyen (ADD, COPY, RUN vb.) her satÄ±r, imaja yeni bir katman ekler; dolayÄ±sÄ±yla boyutunu artÄ±rÄ±r. Bu nedenle, dosyanÄ±n yukarÄ±dan aÅŸaÄŸÄ±ya doÄŸru okunduÄŸunu unutmayarak, deÄŸiÅŸmeyecek kÄ±sÄ±mlarÄ± mÃ¼mkÃ¼n olduÄŸunca yukarÄ±ya eklemeli ve komutlarÄ± zincirlemelisiniz. 8. satÄ±rdaki apt komutlarÄ±nÄ±n zincirlenmesi, iÅŸletim sistemi gÃ¼ncellemelerinin tek bir katmanda yer almasÄ±nÄ± saÄŸlÄ±yor.\n9â€“12. satÄ±rlar arasÄ±nda uygulamanÄ±n Ã§alÄ±ÅŸmasÄ± iÃ§in gereken baÄŸÄ±mlÄ±lÄ±klarÄ± kurup (RUN), uygulamayÄ± derliyoruz.\nsatÄ±rda NODE_ENV adÄ±nda bir Ã§evresel deÄŸiÅŸken tanÄ±mlayÄ±p (NODE_ENV) Ã¶ntanÄ±mlÄ± deÄŸerini production yapÄ±yoruz. Bu, yukarÄ±da bahsettiÄŸim gerÃ§ek ortama yÃ¶nelik imaj oluÅŸturma prensibiyle de Ã¶rtÃ¼ÅŸÃ¼yor. Ã‡alÄ±ÅŸma zamanÄ±nda -e NODE_ENV=development parametresiyle Ã¶ntanÄ±mlÄ± deÄŸeri ezebiliyoruz.\nsatÄ±rda, 3000. baÄŸlantÄ± noktasÄ±nÄ±n dÄ±ÅŸarÄ±dan kullanÄ±labileceÄŸini (EXPOSE) belirtiyorum. YukarÄ±da belirttiÄŸim gibi, Ã§alÄ±ÅŸma zamanÄ±nda -p 3000:3000 ya da -P gibi bir parametreyle bu baÄŸlantÄ± noktasÄ±nÄ± ev sahibi makineye baÄŸlamam gerekiyor.\nSon olarak 17. satÄ±rdaki CMD komutuyla Ã¶ntanÄ±mlÄ± olarak, daha Ã¶nce WORKDIR ile belirlediÄŸimiz dizindeki (/srv) app.js dosyasÄ±nÄ±n Ã§alÄ±ÅŸtÄ±rÄ±lacaÄŸÄ±nÄ± belirtiyoruz. Bu satÄ±rda CMD yerine ENTRYPOINT kullanarak da aynÄ± iÅŸi yapabilirdik ama CMD daha esnek olduÄŸundan onu tercih edebiliriz. Serinin ikinci bÃ¶lÃ¼mÃ¼nde bahsettiÄŸim gibi docker run komutlarÄ±nÄ±n sonunda cat vb. terminal komutlarÄ±nÄ± Ã§aÄŸÄ±rabiliyoruz. Bunu CMDâ€™e borÃ§luyuz. ENTRYPOINT kullanÄ±yor olsaydÄ±k, imaj iÃ§in belirlenen komut dÄ±ÅŸÄ±nda bir komutu Ã§aÄŸÄ±ramÄ±yor olacaktÄ±k.\nDockerfileâ€™la ilgili bu kÄ±smÄ± diÄŸer kullanÄ±ÅŸlÄ± bazÄ± komutlarÄ± aÃ§Ä±klayarak kapatayÄ±m:\nLABEL OluÅŸturulacak imajÄ±n sahip olacaÄŸÄ± Ã¶ntanÄ±mlÄ± etiketleri belirler. Ã–lÃ§eklenebilirliÄŸin Ã¶nemli olduÄŸu durumlarda docker run ile etiket vermektense bu ÅŸekilde etiketler tanÄ±mlamak daha mantÄ±klÄ± ve kolay.\nLABEL type=\"node\" purpose=\"api\" role=\"core\" description=\"REST API\" VOLUME YukarÄ±daki KalÄ±cÄ± Veri Depolama kÄ±smÄ±nda bahsettiÄŸim gibi containerâ€™lara dÄ±ÅŸarÄ±dan disk alanlarÄ± baÄŸlayabiliyoruz. Dockerfileâ€™a ekleyeceÄŸiniz VOLUME komutlarÄ±yla container iÃ§indeki disk alanlarÄ±nÄ±n dÄ±ÅŸarÄ±dan baÄŸlanabileceÄŸini belirtmiÅŸ oluyorsunuz.\nVOLUME [â€œ/dataâ€] VOLUME /data USER Container iÃ§inde Ã§alÄ±ÅŸan sÃ¼reÃ§ler siz aksini belirtmediÄŸiniz sÃ¼rece root kullanÄ±cÄ±sÄ±yla Ã§alÄ±ÅŸtÄ±rÄ±lÄ±r. Bu da Dockerâ€™daki olasÄ± bir aÃ§Ä±ÄŸÄ±n kÃ¶tÃ¼ye kullanÄ±lmasÄ±yla istenmeyen sonuÃ§lara sebebiyet verebilir. Bu tip durumlarÄ±n Ã¶nÃ¼ne geÃ§mek iÃ§in Ã¶zellikle proje baÄŸÄ±mlÄ±lÄ±klarÄ±nÄ± kurmadan Ã¶nce USER komutunu vermiÅŸ olmanÄ±z iyi olur. Bu sayede baÄŸÄ±mlÄ±lÄ±klarÄ±n dosya/dizin sahipliÄŸi de bu kullanÄ±cÄ±ya ait olur.\nARG Ã‡evresel durumlarÄ±n yetiÅŸmediÄŸi bazÄ± durumlarda imajlarÄ±nÄ±zÄ± parametrik Ã¼retmek isterseniz ARG komutuyla deÄŸiÅŸkenler ve Ã¶ntanÄ±mlÄ± deÄŸerlerini tanÄ±mlayabilirsiniz. Bu tanÄ±mlar docker build komutunda, imajÄ±nÄ±z yaratÄ±lÄ±rken kullanÄ±lÄ±r.\nARG user1=someuser ARG buildno=1 ÅŸeklinde deÄŸiÅŸkenler tanÄ±mladÄ±ÄŸÄ±nÄ±zÄ± varsayarsak; Ã¶rneÄŸin buildnoâ€™yu imaj oluÅŸturulurken deÄŸiÅŸtirmek isterseniz:\ndocker build --build-arg buildno=2 -t tunix/alperkan.at . ÅŸeklinde yapabilirsiniz.\nHEALTHCHECK Docker 1.12 ile eklenen bu Ã¶zellik sayesinde containerâ€™Ä±n olmasÄ± gerektiÄŸi gibi Ã§alÄ±ÅŸÄ±p Ã§alÄ±ÅŸmadÄ±ÄŸÄ±nÄ± kontrol eden bir komutun belirli sÄ±klÄ±kta ve belirli zaman dilimlerinde Ã§alÄ±ÅŸmasÄ±nÄ± saÄŸlayabilirsiniz. Bu metrikleri takip eden baÅŸka servislerle yeni bir container baÅŸlatÄ±lmasÄ±nÄ±, mevcut containerâ€™Ä±n yeniden baÅŸlatÄ±lmasÄ±nÄ± saÄŸlayabilir ya da Ã§eÅŸitli alarm sistemlerini tetikleyebilirsiniz.\nHEALTHCHECK --interval=5m --timeout=3s \\ CMD curl -f http://localhost/ || exit 1 Kendi Ä°majÄ±nÄ±zÄ± HazÄ±rlamak Diyelim ki elinizde, Dockerâ€™laÅŸtÄ±rmak istediÄŸiniz bir projeniz var; ne yapmalÄ±sÄ±nÄ±z? Bu sorunun cevabÄ±nÄ± vermek iÃ§in Monitise MEAâ€™da aÃ§Ä±k kaynak olarak GitHubâ€™a koyduÄŸumuz Gerrit Dashboard Server projesini Ã¶rnek olarak kullanacaÄŸÄ±m.\nProjeyi kendi makinenize indirdikten sonra;\nnpm install gulp komutlarÄ±yla baÄŸÄ±mlÄ±lÄ±klarÄ± kurup projeyi derleyin. Son komutla, Node.js ile yazÄ±lmÄ±ÅŸ projenin derlenmiÅŸ hali dist dizinine yerleÅŸtiriliyor. Bu dizini, node imajlarÄ±ndan birini baz alan bir containerâ€™Ä±n iÃ§ine kopyalayÄ±p Ã§alÄ±ÅŸtÄ±rmalÄ±yÄ±m. Dockerfileâ€™a bakarsak;\nGerrit Dashboard Server projesinden Docker imajÄ± Ã¼retme iÅŸini Travis CI Ã¼stÃ¼nde yapÄ±yoruz. Ã–ncelikle imajÄ±n doÄŸru ÅŸekilde Ã¼retildiÄŸinden emin olmak iÃ§in kendi makinemizde kurulu olan Docker Engine Ã¼stÃ¼nde deneyelim:\ndocker build -t gerrit-dashboard-server:1.0.2 . Ä°ÅŸlem baÅŸarÄ±lÄ± bir ÅŸekilde sonuÃ§landÄ±ÄŸÄ±nda docker images komutunu verdiÄŸinizde imajÄ±n oluÅŸturulduÄŸunu doÄŸrulayabilmelisiniz.\nÄ°majÄ± daÄŸÄ±tÄ±ma Ã§Ä±karmadan Ã¶nce kullanÄ±labilecek parametrelerle birlikte doÄŸru ÅŸekilde Ã§alÄ±ÅŸtÄ±ÄŸÄ±ndan emin olun.\nOluÅŸturduÄŸunuz imajÄ± baÅŸka bir makineye kopyalamak iÃ§in 2 seÃ§eneÄŸiniz var:\nDocker Engineâ€™den arÅŸivlenmiÅŸ ÅŸekilde dÄ±ÅŸa aktarmak Docker Store benzeri bir servise yÃ¼klemek Docker Engineâ€™den arÅŸivlenmiÅŸ ÅŸekilde dÄ±ÅŸa aktarmak iÃ§in;\ndocker save -o ~/Desktop/gerritdashboard-1.0.2.tar \\ gerrit-dashboard-server:1.0.2 komutunu kullanabilirsiniz. OluÅŸan tar dosyasÄ±nÄ± diÄŸer makineye kopyaladÄ±ktan sonra yeniden iÃ§eri aktarÄ±m yapmak iÃ§inse;\ndocker load -i gerritdashboard-1.0.2.tar komutunu kullanabilirsiniz.\nDocker Store \u0026 Registry Docker imajlarÄ±nÄ± saklamanÄ±n en kolay yollarÄ±ndan birisi Docker Storeâ€™a yÃ¼klemek. Ã‡oÄŸunlukla baz imajlarÄ± indirmek iÃ§in en temel kaynak olarak kullandÄ±ÄŸÄ±mÄ±z Docker Hub (yeni adÄ±yla Docker Store) aslÄ±nda kendi imajlarÄ±mÄ±za da ev sahipliÄŸi yapabilecek bir depo. Genele aÃ§Ä±k imajlarÄ±nÄ±zÄ± sÄ±nÄ±rsÄ±zca yÃ¼kleyebileceÄŸiniz servis, Ã¶zel imajlarÄ±nÄ±z iÃ§in 5 adede kadar Ã¼cretsiz olanak saÄŸlÄ±yor. SonrasÄ± iÃ§inse Ã¼cretli Ã¼yeliklerden birine geÃ§ilmesi gerekiyor.\nEÄŸer oluÅŸturduÄŸunuz imajÄ± herkese aÃ§Ä±k olarak yÃ¼klemenizde bir sakÄ±nca yoksa Docker Hubâ€™a Ã¼cretsiz olarak yÃ¼kleyebilirsiniz. Bunun iÃ§in Ã¶ncelikle servise kayÄ±t olmalÄ±sÄ±nÄ±z. KayÄ±t olduktan sonra kullanÄ±cÄ± bilgilerinizle giriÅŸ yapÄ±n ve yeni bir Docker imaj deposu (repository) oluÅŸturun. Bunun iÃ§in tercih edebileceÄŸiniz 2 yol var:\nManuel Depo Docker Hubâ€™da manuel depo oluÅŸturma formu\nGiriÅŸ yaptÄ±ktan sonra saÄŸ Ã¼stteki Create menÃ¼sÃ¼nden Create Repositoryâ€™e basÄ±n. Formdaki alanlarÄ± doldurduktan sonra Create tuÅŸuna basÄ±n. Åimdi imajÄ± yÃ¼kleme zamanÄ±! ğŸ¤˜ğŸ»\nYÃ¼kleme yapabilmek iÃ§in bilgisayarÄ±nÄ±zdan Docker Hubâ€™a giriÅŸ yapmak iÃ§in;\ndocker login komutunu verin. E-posta adresinizi ve ÅŸifrenizi yazÄ±p doÄŸrulamadan geÃ§tikten sonra ev dizininizdeki ~/.docker/config.json dosyasÄ±na ilgili servise ait giriÅŸ bilgileri (yetki kodu ve e-posta adresiniz) yazÄ±lacaktÄ±r. Bu iÅŸlem, aynÄ± servisi kullandÄ±ÄŸÄ±nÄ±z sÃ¼rece tek seferliktir; tekrarlamanÄ±z gerekmez.\nYukardaki son Ã¶rneÄŸimizden devam edelim. Ä°majÄ±mÄ±zÄ± gerrit-dashboard-server:1.0.2 adÄ±yla oluÅŸturmuÅŸtuk. Docker Engine, imajÄ± uzaktaki bir servise yÃ¼kleyeceÄŸimizde nereye yÃ¼kleyeceÄŸini imajÄ±n adÄ±ndan buluyor. Bu nedenle imajÄ± yeniden oluÅŸturmamÄ±za gerek yok; etiketleri kullanarak iÅŸlemi gerÃ§ekleÅŸtirebiliriz. Docker Hub servisi iÃ§in imajÄ± etiketleyelim:\ndocker tag gerrit-dashboard-server:1.0.2 docker.io/tunix/gerritdashboard-server:1.0.2 ArtÄ±k imajÄ± Docker Hubâ€™a yÃ¼kleyebiliriz:\ndocker push docker.io/tunix/gerritdashboard-server:1.0.2 Ä°ÅŸlem node imajÄ±nÄ± baz alÄ±p Ã¼stÃ¼ne sadece kendi katmanlarÄ±mÄ±zÄ± eklediÄŸimizden hÄ±zlÄ±ca tamamlanacaktÄ±r. ArtÄ±k Docker Engine yÃ¼klÃ¼ olan herhangi bir makinede;\ndocker pull docker.io/tunix/gerritdashboard-server:1.0.2 komutuyla imajÄ± indirip kullanmaya baÅŸlayabilirsiniz.\nOtomatik Depo Docker Hubâ€™da otomatik depo oluÅŸturma formu\nGiriÅŸ yaptÄ±ktan sonra saÄŸ Ã¼stteki Create menÃ¼sÃ¼nden Create Automated Buildâ€™a basÄ±n. KarÅŸÄ±nÄ±za yukarÄ±daki gibi GitHub ya da Bitbucket arasÄ±nda seÃ§im yapmanÄ±z gereken bir ekran gelecek. SeÃ§iminizi yaptÄ±ÄŸÄ±nÄ±zda ilgili servisin sitesine gidip kod depolarÄ±nÄ±za eriÅŸim hakkÄ± vermeniz gerekecektir. Bu adÄ±mÄ± gerÃ§ekleÅŸtirdikten sonra kod depolarÄ±nÄ±zÄ± seÃ§meniz iÃ§in aÅŸaÄŸÄ±daki gibi bir ekran gÃ¶receksiniz:\nGitHub kod depolarÄ±nÄ± listeleyen sayfadan istediÄŸinizi seÃ§in\nSeÃ§iminizi yaptÄ±ÄŸÄ±nÄ±zda karÅŸÄ±nÄ±za otomatik depo oluÅŸturmanÄ±n son adÄ±mÄ± olan form Ã§Ä±kacaktÄ±r; formu doldurup Create tuÅŸuna bastÄ±ÄŸÄ±nÄ±zda deponuz oluÅŸturulacak ve ilk derleme iÅŸlemi iÃ§in beklemeye baÅŸlayacaktÄ±r. AslÄ±nda kod deposu seÃ§imini yaptÄ±ÄŸÄ±nÄ±zda arkaplanda seÃ§im yaptÄ±ÄŸÄ±nÄ±z depoya bir webhook (aÄŸ kancasÄ±? ğŸ˜‚) eklenir. Kod deposuna yeni kod parÃ§acÄ±ÄŸÄ± gÃ¶nderdiÄŸinizde Docker Hubâ€™da otomatik olarak bir derlenme sÃ¼reci tetiklenecek ve oluÅŸturulan imajÄ±nÄ±z sayfada yer alacaktÄ±r.\nGitHubâ€™daki digitalocean-dyndns adlÄ± projemin Docker imajlarÄ± Docker Hub tarafÄ±ndan otomatik oluÅŸturuluyor.\nDocker Registry Docker Hub bu servisi verirken arkaplanda Docker Registry (yeni adÄ±yla Docker Distribution) adÄ± verilen aÃ§Ä±k kaynak kodlu bir yazÄ±lÄ±mÄ± kullanÄ±yor. EÄŸer imajlarÄ±nÄ±zÄ± yÃ¼klemek iÃ§in bir registryâ€™e para vermek istemiyorsanÄ±z kendi registryâ€™nizi kurabilirsiniz. Ancak bÃ¶yle bir tercihte bulunacaksanÄ±z kurulum yapacaÄŸÄ±nÄ±z sunucunun yÃ¶netimini ve maliyetlerini de gÃ¶z Ã¶nÃ¼nde bulundurun. Ã–te yandan proje kodlarÄ±nÄ± git vb. bir SKS (sÃ¼rÃ¼m kontrol sistemi) Ã¼stÃ¼nde tuttuÄŸunuz sÃ¼rece geriye dÃ¶nÃ¼p imajÄ± yeniden yaratmanÄ±z mÃ¼mkÃ¼n olabileceÄŸinden riskiniz o kadar da yÃ¼ksek deÄŸil. Yine de kodunuzun o anki hali deÄŸilse bile bulunduÄŸu ortamÄ±n ve baÄŸÄ±mlÄ±lÄ±klarÄ±n sÄ±kÄ±ntÄ± Ã§Ä±karabileceÄŸini unutmayÄ±n. ğŸ¤”\nKendi Docker Registryâ€™nizi Kurun Monitise MEAâ€™da hibrid bir geliÅŸtirme ve test ortamÄ±mÄ±z var. Klasik ÅŸekilde bir VM Ã¼stÃ¼ne kurulu Tomcatâ€™e yÃ¼klenen sayÄ±sÄ±z projemiz olduÄŸu gibi, yeni projelerimizde Dockerâ€™Ä± kullanma seÃ§eneÄŸini her zaman gÃ¶z Ã¶nÃ¼nde bulunduruyoruz. GerÃ§ek ortamda Dockerâ€™Ä± hiÃ§ kullanmayan projelerde dahi bazÄ± durumlarda geliÅŸtirme ve test ortamÄ± iÃ§in Dockerâ€™Ä± tercih edebiliyoruz. DolayÄ±sÄ±yla bu projelerin Docker imajlarÄ±nÄ± Ã¼retmemiz ve sunucular arasÄ±nda taÅŸÄ±maya ihtiyacÄ±mÄ±z var ve Docker Registry burada devreye giriyor.\nÃ–zetle, Docker Registry bir APIâ€™dan ve disk Ã¼stÃ¼nde imaj katmanlarÄ±nÄ± yÃ¶neten bir sistemden oluÅŸuyor. API v1 iken Docker Registry adÄ±nÄ± taÅŸÄ±rken, v2 ile birlikte Docker Distribution adÄ±nÄ± aldÄ±. Her ikisi de Docker Storeâ€™dan indirilebilir durumda. Kurmak iÃ§in;\ndocker run -d -p 5000:5000 --name registry registry:2 komutunu vermeniz yeterli. Bu durumda aÅŸaÄŸÄ±daki Ã¶ntanÄ±mlÄ± deÄŸerler geÃ§erli olur:\nÄ°majlarÄ±nÄ±z container iÃ§indeki /var/lib/registry dizini altÄ±na yazÄ±lÄ±r. Ã–ntanÄ±mlÄ± olarak filesystem sÃ¼rÃ¼cÃ¼sÃ¼ kullanÄ±lÄ±r. Alternatifler ÅŸurada. Registryâ€™nize, herhangi bir SSL sertifikasÄ±na sahip olmadÄ±ÄŸÄ±ndan, HTTP Ã¼stÃ¼nden ulaÅŸÄ±rsÄ±nÄ±z. Registryâ€™niz herkesin yÃ¼klemesine ve indirmesine aÃ§Ä±k ÅŸekilde Ã§alÄ±ÅŸÄ±r; kullanÄ±cÄ±larÄ±n Ã¶nce giriÅŸ yapmalarÄ± gerekmez. KullandÄ±ÄŸÄ±nÄ±z aÄŸÄ±n dÄ±ÅŸarÄ±ya aÃ§Ä±k olmamasÄ± durumunda bu ÅŸekilde de Ã§alÄ±ÅŸabilirsiniz. Registry kurulumuyla ilgili en gÃ¼ncel bilgiyi ÅŸuradan bulabilirsiniz. Benim tavsiyem; registry iÃ§in ev sahibi makineye ek disk vermeniz ve containerâ€™daki /var/lib/registry dizinini ev sahibi makinedeki /registry dizinine baÄŸlamanÄ±z yÃ¶nÃ¼nde. AyrÄ±ca registryâ€™i kullanan tÃ¼m makinelerde ek ayar (--insecure-registry) yapmamak iÃ§in sunucuya geÃ§erli bir sertifika kurmanÄ±zda fayda var. LetsEncrypt gibi gÃ¼zelliklerin olduÄŸu gÃ¼nÃ¼mÃ¼zde yapmazsanÄ±z ayÄ±p! ğŸ˜‰ Tabii sertifika iÅŸini registryâ€™nin Ã¶nÃ¼ne bir HTTP sunucusu (nginx, Apache vb.) koyarak da Ã§Ã¶zebilirsiniz. Hatta HTTP sunucusu yerine https-proxyâ€™i de kullanabilirsiniz.\nSon durumda registry kurulumu iÃ§in aÅŸaÄŸÄ±daki gibi bir komuta ihtiyacÄ±nÄ±z var:\ndocker run -d --name registry \\ -p 5000:5000 \\ --restart=always \\ -v /registry:/var/lib/registry \\ registry:2 https-proxy kullanmak isteyenlere bonus olarak Ã¶rnek komutu ekleyeyim:\ndocker run -d --name registry-ssl \\ -e KEY=â€$(cat registry.key)â€ \\ -e CERT=â€$(cat registry.crt)â€ \\ -p 443:443 \\ -e PORT=5000 \\ --restart=always \\ --link registry:www \\ yajo/https-proxy registry containerâ€™Ä±nÄ± yaratÄ±rken kullandÄ±ÄŸÄ±nÄ±z ismin, https-proxyâ€™i yaratÄ±rken kullandÄ±ÄŸÄ±nÄ±z komuttaki â€“link bÃ¶lÃ¼mÃ¼ndeki registry ismiyle aynÄ± olduÄŸundan emin olun.\nDiyelim ki; registryâ€™inize ulaÅŸtÄ±ÄŸÄ±nÄ±z adres docker.example.com olsun. Bu durumda imajlarÄ±nÄ±zÄ± buraya yÃ¼klemek iÃ§in docker.example.com/tunix/alperkan.at:1.0.2 gibi isimlendirmelisiniz. docker push komutuyla imajÄ±nÄ±zÄ± yÃ¼klerken, Docker Engine otomatik olarak HTTPS protokolÃ¼nÃ¼ tercih edecektir. Bu nedenle SSL adÄ±mÄ±nÄ± atladÄ±ysanÄ±z ve kendi makinenizden yÃ¼kleme yapÄ±yorsanÄ±z Docker Engine ayarlarÄ±nda yeni registryâ€™inizi â€œInsecure Registriesâ€ bÃ¶lÃ¼mÃ¼nden ekleyin. Linuxâ€™da bu arayÃ¼z geliyor mu emin deÄŸilim ama ÅŸuradaki adÄ±mlarÄ± takip edebilirsiniz.\nBu bÃ¶lÃ¼mÃ¼nÃ¼n de sonuna geldik. Bir sonraki bÃ¶lÃ¼mde Docker Composeâ€™dan ve Ã¶zellikle birden fazla parÃ§aya ihtiyaÃ§ duyan projelerinizi Docker ile nasÄ±l kolayca ayaÄŸa kaldÄ±rabileceÄŸinizden bahsedeceÄŸim.\nGidiÅŸÃ¢ta gÃ¶re bu planda zaman zaman deÄŸiÅŸiklikler yapacak olsam da serinin tÃ¼m bÃ¶lÃ¼mlerinin planÄ±na ÅŸuradan ulaÅŸabilirsiniz.\n",
  "wordCount" : "2842",
  "inLanguage": "tr",
  "datePublished": "2016-10-13T00:00:00Z",
  "dateModified": "2021-04-25T17:47:11+03:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://alperkan.at/tr/2016/10/docker-serisi-3/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Alper Kanat",
    "logo": {
      "@type": "ImageObject",
      "url": "https://alperkan.at/favicon.ico"
    }
  }
}
</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://alperkan.at/tr/ accesskey=h title="Alper Kanat (Alt + H)">Alper Kanat</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://alperkan.at/ title=ğŸ‡¬ğŸ‡§ aria-label=ğŸ‡¬ğŸ‡§>En</a></li></ul></span></div><ul id=menu><li><a href=https://alperkan.at/tr/arsiv title=arÅŸiv><span>arÅŸiv</span></a></li><li><a href=https://alperkan.at/tr/tags title=etiketler><span>etiketler</span></a></li><li><a href=https://alperkan.at/tr/hakkimda title=hakkÄ±mda><span>hakkÄ±mda</span></a></li><li><a href=https://github.com/tunix/notebook title=notlarÄ±m><span>notlarÄ±m</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Docker Serisi #3 -- Docker Engine BÃ¶lÃ¼m 2</h1><div class=post-meta>October 13, 2016</div></header><div class=post-content><p>Docker Serisiâ€™nin 3. bÃ¶lÃ¼mÃ¼ne hoÅŸgeldiniz! <a href=https://alperkan.at/tr/2016/07/docker-serisi-1/>Ä°lk bÃ¶lÃ¼mde</a> sanallaÅŸtÄ±rmanÄ±n ne olduÄŸundan,
container teknolojisinden ve temel Docker kavramlarÄ±ndan; <a href=https://alperkan.at/tr/2016/09/docker-serisi-2/>ikinci bÃ¶lÃ¼mde</a> Docker Engine
ve Docker komutlarÄ±ndan bahsetmiÅŸtim. Bu bÃ¶lÃ¼mdeyse Ã¶zetle ÅŸu konulara deÄŸineceÄŸim:</p><ul><li><a href=#kalÄ±cÄ±-veri-depolama>KalÄ±cÄ± Veri Depolama</a></li><li><a href=#Ã§evresel-deÄŸiÅŸkenler>Ã‡evresel DeÄŸiÅŸkenler</a></li><li><a href=#baÄŸlantÄ±-noktalarÄ±>BaÄŸlantÄ± NoktalarÄ±</a></li><li><a href=#dockerfile>Dockerfile</a></li><li><a href=#kendi-imajÄ±nÄ±zÄ±-hazÄ±rlamak>Kendi Ä°majÄ±nÄ±zÄ± HazÄ±rlamak</a></li><li><a href=#docker-store--registry>Docker Store & Registry</a></li><li><a href=#kendi-docker-registrynizi-kurun>Kendi Docker Registryâ€™nizi Kurun</a></li></ul><p>HÄ±zlÄ±ca baÅŸlayalÄ±m! ğŸ™‚</p><hr><h3 id=kalÄ±cÄ±-veri-depolama>KalÄ±cÄ± Veri Depolama<a hidden class=anchor aria-hidden=true href=#kalÄ±cÄ±-veri-depolama>#</a></h3><p><a href=https://alperkan.at/tr/2016/09/docker-serisi-2/#docker-run->Ä°kinci bÃ¶lÃ¼mÃ¼n docker run komutuyla ilgili olan kÄ±smÄ±nda</a> containerâ€™lara
dÄ±ÅŸarÄ±dan dosya ve dizin baÄŸlanabileceÄŸinden bahsetmiÅŸtim. Normalde, Ã¶lÃ§eklenebilirliÄŸin Ã¶n planda olduÄŸu gerÃ§ek ortam
containerâ€™larÄ± dÄ±ÅŸarÄ±dan baÄŸÄ±msÄ±z Ã§alÄ±ÅŸabilecek ÅŸekilde tasarlanmalÄ±dÄ±r. AslÄ±nda bakarsanÄ±z Ã¶lÃ§eklenebilirliÄŸin
maksimize edilmesi iÃ§in uygulamanÄ±zÄ±n, <a href=https://12factor.net/>12 FaktÃ¶r prensibine</a> uygun tasarlanmÄ±ÅŸ olmasÄ± gerekir.
Bu prensiplere uyarak Ã¶rneÄŸin uygulamanÄ±zdan N tane container baÅŸlatarak Ã¶lÃ§eklenebilirliÄŸi rahatlÄ±kla
saÄŸlayabilirsiniz.</p><p>Ã–lÃ§eklenebilirliÄŸin Ã§ok sorun olmadÄ±ÄŸÄ± durumlarda ya da geliÅŸtirme/test ortamlarÄ±nda dosya/dizin baÄŸlamak size bÃ¼yÃ¼k
kolaylÄ±k saÄŸlar. Ã–rneÄŸin uygulama kayÄ±tlarÄ±nÄ±zÄ± (log) merkezi bir servis yerine yerel dosya sistemine yazÄ±yorsanÄ±z,
ilgili dizini ev sahibi makineye baÄŸlamak akÄ±lcÄ± olacaktÄ±r. Ya da uygulamalarÄ±nÄ±zÄ± Tomcatâ€™e dizin aÃ§arak yÃ¼klÃ¼yorsanÄ±z
<code>webapps</code> dizinini ev sahibi makineye baÄŸlamak isteyebilirsiniz.</p><p>Containerâ€™larda kalÄ±cÄ± veri depolama (persistence) sÃ¶z konusu olduÄŸunda 3 tip depolamadan bahsetmek mÃ¼mkÃ¼n:</p><h4 id=ev-sahibi-makineden-dizindosya-baÄŸlayarak-depolamak>Ev sahibi makineden dizin/dosya baÄŸlayarak depolamak<a hidden class=anchor aria-hidden=true href=#ev-sahibi-makineden-dizindosya-baÄŸlayarak-depolamak>#</a></h4><p>Bu yÃ¶ntemde ev sahibi makineyi paylaÅŸÄ±mlÄ± dizin gibi dÃ¼ÅŸÃ¼nebiliriz. Bir kaÃ§ Ã¶rnek senaryo sayarsam:</p><ul><li>nginx kurarken <code>/etc/nginx/nginx.conf</code>â€™u ev sahibi makineden baÄŸlayarak Ã¼zerinde deÄŸiÅŸiklik yapmayÄ± kolaylaÅŸtÄ±rmak</li><li>nginx imajÄ±nda hiÃ§ bir deÄŸiÅŸiklik yapmaksÄ±zÄ±n ev sahibi makinede tuttuÄŸum statik web uygulamamÄ±n dizinini
<code>/var/www/html</code> dizinine baÄŸlayarak doÄŸrudan sunmak</li><li>Ev sahibi makinede tuttuÄŸum, PHP ile geliÅŸtirdiÄŸim kod tabanÄ±mÄ± container ile paylaÅŸarak yaptÄ±ÄŸÄ±m deÄŸiÅŸikliklerin
sonucunu container Ã¼stÃ¼nden anÄ±nda gÃ¶rmek</li><li>Ev sahibi makinede bulunan bir dizindeki tÃ¼m dosyalarÄ±, containerâ€™Ä±n iÃ§inde Ã§alÄ±ÅŸacak bir program ile iÅŸleyip aynÄ±
dizine yeniden yazmak</li><li>Ev sahibi makinede Ã§alÄ±ÅŸan Docker Engineâ€™in Ã§alÄ±ÅŸma dizinini, containerâ€™a baÄŸlayarak Docker Engineâ€™de bazÄ± iÅŸlemler
yapmak (Ã¶r: <a href=https://github.com/meltwater/docker-cleanup>docker-cleanup</a>)</li></ul><p>Peki dosya ya da dizinleri nasÄ±l baÄŸlÄ±yoruz? YukarÄ±daki bir kaÃ§ Ã¶rneÄŸi gerÃ§ekleyelim:</p><p><strong>DÄ±ÅŸarÄ±dan /etc/nginx/nginx.confâ€™u baÄŸlamak:</strong></p><pre tabindex=0><code>docker run -d --name nginx1 -v /home/alper/nginx/nginx.conf:/etc/nginx/nginx.conf -p 8000:80 nginx
</code></pre><p><strong>DÄ±ÅŸarÄ±dan statik web uygulamasÄ±nÄ±n dizinini baÄŸlamak:</strong></p><pre tabindex=0><code>docker run -d --name nginx2 -v /home/alper/web:/var/www/html -p 8001:80 nginx
</code></pre><p><strong>DÄ±ÅŸarÄ±dan dizin baÄŸlayÄ±p iÃ§indeki dosyalarÄ± iÅŸlemek:</strong></p><pre tabindex=0><code>docker run --rm -v /home/alper/test:/test ubuntu sed â€˜/kanat/dâ€™ /test/deneme.txt
</code></pre><h4 id=depolayÄ±cÄ±-containerlar-kullanmak>DepolayÄ±cÄ± containerâ€™lar kullanmak<a hidden class=anchor aria-hidden=true href=#depolayÄ±cÄ±-containerlar-kullanmak>#</a></h4><p>KalÄ±cÄ± veri depolamanÄ±n Dockerâ€™ca yolu, depolayÄ±cÄ± containerâ€™lar kullanmaktan geÃ§iyor. DepolayÄ±cÄ± containerâ€™larÄ±n
avantajlarÄ± kabaca ÅŸÃ¶yle:</p><ul><li>Ä°lgili alanÄ± birden fazla container ile paylaÅŸabilirsiniz.</li><li>Bir containerâ€™a birden fazla depolayÄ±cÄ± container baÄŸlayabilirsiniz.</li><li>DepolayÄ±cÄ± containerâ€™lar, beraber Ã§alÄ±ÅŸtÄ±klarÄ± containerâ€™lar Ã¶lse dahi silinmez; tekrar tekrar kullanÄ±labilirler.</li></ul><p>DepolayÄ±cÄ± container yaratmak iÃ§in;</p><pre tabindex=0><code>docker create -v /dbdata --name dbstore training/postgres /bin/true
</code></pre><p>DepolayÄ±cÄ± containerâ€™Ä± baÄŸlamak iÃ§in;</p><pre tabindex=0><code>docker run -d --volumes-from dbstore --name db1 training/postgres
</code></pre><p>yazabilirsiniz. Bu sayede <code>db1</code> adÄ±ndaki containerâ€™Ä±nÄ±zÄ±n iÃ§indeki <code>/dbdata</code> dizini, aslÄ±nda <code>dbstore</code> containerâ€™Ä±ndan
baÄŸlanmÄ±ÅŸ olacaktÄ±r. Diyelim ki; disk alanÄ±nÄ± yedeklemek istiyoruz. Yeni bir container ile aynÄ± depolayÄ±cÄ± containerâ€™Ä±
baÄŸlayarak bu iÅŸlemi gerÃ§ekleÅŸtirebiliriz:</p><pre tabindex=0><code>docker run --rm --volumes-from dbstore -v $(pwd):/backup ubuntu tar cvf /backup/backup.tar /dbdata
</code></pre><p>Bu komutun yaptÄ±klarÄ±nÄ± kÄ±saca Ã¶zetlersek;</p><ul><li>Ã‡alÄ±ÅŸtÄ±ktan sonra silinecek ÅŸekilde, Ubuntu imajÄ±ndan yeni bir container yarat (<code>docker run --rm</code>)</li><li>Bu containerâ€™a dbstore adlÄ± depolayÄ±cÄ± containerâ€™Ä±ndan dÄ±ÅŸarÄ± aÃ§Ä±lan dizinleri baÄŸla (<code>--volumes-from dbstore</code>)</li><li>Ev sahibi makine Ã¼stÃ¼nde bulunduÄŸum dizini, container iÃ§erisindeki <code>/backup</code> dizinine baÄŸla. (<code>-v $(pwd):/backup</code>)</li><li>Container Ã¼stÃ¼ndeki <code>/dbdata</code> dizinini sÄ±kÄ±ÅŸtÄ±rarak ev sahibi makine Ã¼stÃ¼nde <code>/backup/backup.tar</code> olarak kaydet.</li></ul><h4 id=paylaÅŸÄ±mlÄ±-disk-alanlarÄ±-kullanmak>PaylaÅŸÄ±mlÄ± Disk AlanlarÄ± Kullanmak<a hidden class=anchor aria-hidden=true href=#paylaÅŸÄ±mlÄ±-disk-alanlarÄ±-kullanmak>#</a></h4><p>Docker, 1.8.0 sÃ¼rÃ¼mÃ¼nden itibaren disk alanlarÄ± iÃ§in sÃ¼rÃ¼cÃ¼ desteÄŸiyle beraber geliyor. Az sonra bahsedeceÄŸim komutlara
ek olarak; Azure, Google Compute Engine, NFS vb. sÃ¼rÃ¼cÃ¼leri parametre olarak geÃ§erek (Ã¶r: <code>--volume-driver=flocker</code>)
farklÄ± servislerden disk alanlarÄ±nÄ± da containerâ€™larÄ±nÄ±za
<a href=https://docs.docker.com/engine/tutorials/dockervolumes/>baÄŸlayabilirsiniz</a>. Herhangi bir sÃ¼rÃ¼cÃ¼ belirtmezseniz
Ã¶ntanÄ±mlÄ± olan yerel disk sÃ¼rÃ¼cÃ¼sÃ¼ (<code>--volume-driver=local</code>) kullanÄ±lÄ±r ve disk alanÄ± makinenizde oluÅŸturulur.</p><p>Yerel disk alanÄ± yaratmak iÃ§in:</p><pre tabindex=0><code>docker volume create --name=shared-disk
</code></pre><p>[YÃ¼kledikten sonra] <a href=https://clusterhq.com/flocker/introduction/>flocker</a> sÃ¼rÃ¼cÃ¼sÃ¼ ile yaratmak iÃ§in:</p><pre tabindex=0><code>docker volume create -d flocker -o size=20GB --name=shared-disk
</code></pre><p>OluÅŸturduÄŸunuz disk alanÄ±nÄ± containerâ€™daki bir bÃ¶lÃ¼me baÄŸlamak iÃ§in:</p><pre tabindex=0><code>docker run -d --name=t1 -v shared-disk:/usr/local/tomcat/webapps -P tomcat
docker run -d --name=t2 -v shared-disk:/usr/local/tomcat/webapps -P tomcat
</code></pre><p>YukarÄ±daki ÅŸekilde 2 tane Tomcat sunucusu baÅŸlatÄ±p aynÄ± disk alanÄ±nÄ± ikisine birden baÄŸlayabiliyoruz.</p><h3 id=Ã§evresel-deÄŸiÅŸkenler>Ã‡evresel DeÄŸiÅŸkenler<a hidden class=anchor aria-hidden=true href=#Ã§evresel-deÄŸiÅŸkenler>#</a></h3><p>Ä°ster web uygulamasÄ± olsun, ister bir API uygulamasÄ±; bir uygulamanÄ±n en Ã¶nemli kÄ±sÄ±mlarÄ±ndan biri yapÄ±landÄ±rma
kÄ±smÄ±dÄ±r. Bazen bu yapÄ±landÄ±rma, uygulamada kullanÄ±lan 3. parti servislerin eriÅŸim bilgileridir, bazense uygulamanÄ±n
nasÄ±l davranacaÄŸÄ±nÄ± belirleyen kritik roldeki bir anahtardÄ±r. YalnÄ±zca bir anahtarÄ±n deÄŸerini deÄŸiÅŸtirerek gerÃ§ek bir
veritabanÄ± yerine Ã¶rnek verilerle Ã§alÄ±ÅŸmasÄ±nÄ± saÄŸlayabilir ya da uygulama iÃ§indeki bir Ã¶zelliÄŸi komple aÃ§Ä±p
kapatabilirsiniz.</p><p>Eski tip yazÄ±lÄ±m paketleme yÃ¶ntemlerinde; uygulama iÃ§erisinde tutulan yapÄ±landÄ±rma dosyalarÄ±nÄ±n deÄŸerleriyle oynayÄ±p
birden fazla paket Ã§Ä±karmak oldukÃ§a yaygÄ±n. Dockerâ€™da ise imajÄ±nÄ±zÄ± gerÃ§ek ortama gÃ¶re hazÄ±rlayÄ±p dÄ±ÅŸarÄ±dan vereceÄŸiniz
Ã§evresel deÄŸiÅŸkenlerle her ÅŸeyi yÃ¶netebilirsiniz.</p><p>TanÄ±mlayacaÄŸÄ±nÄ±z Ã§evresel deÄŸiÅŸkenler, container iÃ§erisinde iÅŸletim sistemi seviyesinde ve tÃ¼m uygulamalarda
eriÅŸilebilir durumda olacaktÄ±r. Bu sayede yapÄ±landÄ±rma dosyalarÄ±nda ya da Ã§alÄ±ÅŸtÄ±rma betiklerinde Ã§evresel
deÄŸiÅŸkenlerinizi kullanabilirsiniz. Bu sayede son derece esnek imajlar yaratmanÄ±z mÃ¼mkÃ¼n.</p><p>Ã‡evresel deÄŸiÅŸkenlerle ilgili serinin ilerleyen bÃ¶lÃ¼mlerinde gerÃ§ekÃ§i Ã¶rnekler vereceÄŸim iÃ§in ÅŸimdilik Tomcat ve MySQL
Ã¶zelinde 2 Ã¶rnekle bu kÄ±smÄ± noktalÄ±yorum:</p><h4 id=tomcat-manager-uygulamasÄ±-ÅŸifresini-belirlemek>Tomcat Manager UygulamasÄ± Åifresini Belirlemek<a hidden class=anchor aria-hidden=true href=#tomcat-manager-uygulamasÄ±-ÅŸifresini-belirlemek>#</a></h4><pre tabindex=0><code>docker run -d -p 8080:8080 -e TOMCAT_PASS=â€mypassâ€ tutum/tomcat
</code></pre><blockquote><p>Burada tutumâ€™un imajÄ±nÄ± kullanma sebebim; orjinal Tomcat imajlarÄ±nda Ã§evresel deÄŸiÅŸkenler ile ÅŸifre belirleme
Ã¶zelliÄŸinin bulunmuyor oluÅŸundan kaynaklanÄ±yor.</p></blockquote><h4 id=mysql-yÃ¶netici-ÅŸifresini-belirlemek>MySQL YÃ¶netici Åifresini Belirlemek<a hidden class=anchor aria-hidden=true href=#mysql-yÃ¶netici-ÅŸifresini-belirlemek>#</a></h4><pre tabindex=0><code>docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql
</code></pre><p>Docker Hubâ€™dan (yeni adÄ±yla Docker Store) indirdiÄŸiniz imajlarÄ±n hangi Ã§evresel deÄŸiÅŸkenleri kullandÄ±ÄŸÄ±nÄ± anlamak iÃ§in
ilgili sayfalarÄ±na bakabilirsiniz. Maalesef bazÄ± imajlarda bu detaylar yeterince belgelendirilmediÄŸi iÃ§in imajlarÄ±n
kaynak kodlarÄ±ndaki <a href=https://medium.com/commencis/docker-serisi-3-docker-engine-bolum-2-a7c6c5f50851#6aea>Dockerfile</a>
dosyalarÄ±nÄ± incelemeniz gerekebilir.</p><h3 id=baÄŸlantÄ±-noktalarÄ±>BaÄŸlantÄ± NoktalarÄ±<a hidden class=anchor aria-hidden=true href=#baÄŸlantÄ±-noktalarÄ±>#</a></h3><p>BaÄŸlantÄ± noktalarÄ± (port) dÄ±ÅŸ dÃ¼nya ile containerâ€™larÄ±nÄ±zÄ±n iletiÅŸimini saÄŸlar. Bir web uygulamasÄ± geliÅŸtirdiÄŸimizi
varsayarsak, containerâ€™daki 80. baÄŸlantÄ± noktasÄ±nÄ± ev sahibi makinedeki herhangi bir baÄŸlantÄ± noktasÄ±na baÄŸlamadan
uygulamamÄ±za eriÅŸemeyiz.</p><p>Docker, Ã§alÄ±ÅŸma zamanÄ±nda Ã¶zellikle belirtmediÄŸiniz sÃ¼rece, Ã¶ntanÄ±mlÄ± olarak herhangi bir baÄŸlantÄ± noktasÄ±nÄ± dÄ±ÅŸarÄ±ya
aÃ§mayacaktÄ±r. Ä°maj hazÄ±rlanÄ±rken baÄŸlantÄ± noktalarÄ±nÄ±n tanÄ±mlarÄ± da <a href=#dockerfile>Dockerfile</a> iÃ§ine
yazÄ±lÄ±r. Ancak yine de containerâ€™Ä± Ã§alÄ±ÅŸtÄ±rÄ±rken, <code>-p</code> ya da <code>-P</code> ile ev sahibi makineye baÄŸlamazsanÄ±z dÄ±ÅŸarÄ±dan
eriÅŸilmez olacaktÄ±r.</p><p>Containerâ€™Ä±n tanÄ±mladÄ±ÄŸÄ± baÄŸlantÄ± noktalarÄ±nÄ± <code>docker ps</code> komutuyla gÃ¶rebilirsiniz: <code>0.0.0.0:80->80/tcp</code>, <code>443/tcp</code> Bu
Ã§Ä±ktÄ±ya baktÄ±ÄŸÄ±mÄ±zda 80. baÄŸlantÄ± noktasÄ±nÄ±n ev sahibi makinedeki tÃ¼m aÄŸlara baÄŸlandÄ±ÄŸÄ±nÄ±, 443. baÄŸlantÄ± noktasÄ±nÄ±n
ise baÄŸlanmadÄ±ÄŸÄ±nÄ± gÃ¶rÃ¼yoruz. Sadece baÄŸlanmÄ±ÅŸ olanlarÄ± gÃ¶rmek iÃ§in <code>docker port container_adi</code> (Ã¶rnek:
<code>docker port nginx</code>) komutunu da kullanabiliriz.</p><h4 id=80-http-ve-443-https-baÄŸlantÄ±-noktalarÄ±nÄ±-baÄŸlayalÄ±m>80 (HTTP) ve 443 (HTTPS) BaÄŸlantÄ± NoktalarÄ±nÄ± BaÄŸlayalÄ±m<a hidden class=anchor aria-hidden=true href=#80-http-ve-443-https-baÄŸlantÄ±-noktalarÄ±nÄ±-baÄŸlayalÄ±m>#</a></h4><p>AÅŸaÄŸÄ±daki komutla ev sahibi makinenin 80. ve 443. baÄŸlantÄ± noktalarÄ±nÄ±, containerâ€™daki 80. ve 443. baÄŸlantÄ± noktalarÄ±na
baÄŸlayabiliriz:</p><pre tabindex=0><code>docker run -d --name nginx -p 80:80 -p 443:443 nginx
</code></pre><h4 id=baÄŸlantÄ±-noktalarÄ±nÄ±-rastgele-baÄŸlayalÄ±m>BaÄŸlantÄ± NoktalarÄ±nÄ± Rastgele BaÄŸlayalÄ±m<a hidden class=anchor aria-hidden=true href=#baÄŸlantÄ±-noktalarÄ±nÄ±-rastgele-baÄŸlayalÄ±m>#</a></h4><p>Java ile yazÄ±lmÄ±ÅŸ bir Spring Boot uygulamanÄ±z olduÄŸunu varsayalÄ±m. Spring Bootâ€™un avantajlarÄ±ndan biri, Tomcatâ€™i
uygulamayla birlikte JAR olarak paketleyebiliyorsunuz. Åimdi uygulamamÄ±zÄ± Docker imajÄ± haline getirdiÄŸimizi ve
yukarÄ±daki yÃ¶ntemle baÅŸlattÄ±ÄŸÄ±mÄ±zÄ± dÃ¼ÅŸÃ¼nelim. <em><strong>AynÄ± ev sahibi makine Ã¼stÃ¼nde bir baÄŸlantÄ± noktasÄ±nÄ± yalnÄ±zca bir
container kullanabilir</strong></em>. Bu nedenle yeniden yukarÄ±daki yÃ¶ntemi kullanmak isterseniz yalnÄ±zca <code>-p 81:80 -p 444:443</code>
yazarak baÅŸlatabilirsiniz.</p><p>Ã–lÃ§eklendirilebilirliÄŸin Ã¶nemli olduÄŸu durumlarda baÄŸlantÄ± noktasÄ±nÄ± sÃ¼rekli elle artÄ±rarak yeni container aÃ§mak pek
kabul edilebilir bir yÃ¶ntem deÄŸil. Bu nedenle doÄŸru olan yÃ¶ntem <code>-P</code> parametresini kullanarak containerâ€™da tanÄ±mlanmÄ±ÅŸ
tÃ¼m baÄŸlantÄ± noktalarÄ±nÄ±n ev sahibi makinedeki rastgele baÄŸlantÄ± noktalarÄ±na atanmasÄ±nÄ± saÄŸlamaktÄ±r. Serinin ileriki
bÃ¶lÃ¼mlerinden &ldquo;GÃ¼nlÃ¼k KullanÄ±m BÃ¶lÃ¼m 1&rdquo; iÃ§erisinde bu yÃ¶ntemden daha detaylÄ± bahsedeceÄŸim.</p><p>Rastgele baÄŸlantÄ± noktasÄ± atamasÄ± iÃ§in aÅŸaÄŸÄ±daki komutu kullanabilirsiniz:</p><pre tabindex=0><code>docker run -d --name nginx -P nginx
</code></pre><h3 id=dockerfile>Dockerfile<a hidden class=anchor aria-hidden=true href=#dockerfile>#</a></h3><p>Dockerfile ile ilgili en detaylÄ± ve gÃ¼ncel bilgiyi <a href=https://docs.docker.com/engine/reference/builder/>kendi sitesinde</a>
bulabilirsiniz. Bu kÄ±sÄ±mda kÄ±saca Dockerfileâ€™Ä± neden ve nasÄ±l kullanmanÄ±z gerektiÄŸini anlatmaya Ã§alÄ±ÅŸacaÄŸÄ±m.
Dockerfile, Ã¶zetle bir Docker imajÄ±nÄ± tarif eder. Hangi imajÄ± baz alacaÄŸÄ±mÄ±zÄ±, baz aldÄ±ÄŸÄ±mÄ±z imajÄ±n Ã¼stÃ¼nde
Ã§alÄ±ÅŸtÄ±racaÄŸÄ±mÄ±z komutlarÄ±, oluÅŸturacaÄŸÄ±mÄ±z dizinleri, dÄ±ÅŸ kullanÄ±ma aÃ§Ä±labilecek Ã§evresel deÄŸiÅŸkenleri, baÄŸlantÄ±
noktalarÄ±nÄ± ve disk alanlarÄ±nÄ± bu dosyada belirtiyoruz. Yine bir Ã¶rnek Ã¼stÃ¼nden ilerleyelim:</p><script type=application/javascript src=https://gist.github.com/tunix/ce6ad7fc6c8c075ab20ee7877307cb23.js></script><p>Her Dockerfile, <code>FROM</code> satÄ±rÄ±yla baÅŸlar. Ä°majÄ±mÄ±zÄ±, <code>node:6.2-slim</code> imajÄ±nÄ± baz alarak yaratacaÄŸÄ±z. <code>-slim</code>â€™i imajÄ±
mÃ¼mkÃ¼n olduÄŸunca kÃ¼Ã§Ã¼ltmek amacÄ±yla kullanÄ±yorum. Ä°majÄ± ilk inÅŸa ettiÄŸimiz noktada ne kadar kÃ¼Ã§Ã¼kten baÅŸlatabilirsek o
kadar iyi. Bu nedenle <a href=https://alpinelinux.org/>Alpine Linux</a>,
<a href=https://store.docker.com/images/e6658267-cc55-421e-b5be-5e69460fb0d1>*-slim</a> vb. seÃ§enekleriniz varsa mutlaka
kullanÄ±n. Ã–rneÄŸin Javaâ€™yla yazÄ±lmÄ±ÅŸ uygulamanÄ±zÄ± Debian ya da Ubuntu imajÄ±nÄ± baz alÄ±p Ã¼stÃ¼ne Java kurarak oluÅŸturmak
yerine, doÄŸrudan <a href=https://store.docker.com/images/199a18b1-511b-47fd-b287-a41555fafb9f>java</a> imajlarÄ±nÄ± tercih
etmelisiniz.</p><p>Zorunlu olmasa da, <a href=https://store.docker.com/>Docker Store</a> vb. yerlerde sorgulanabilmesi ve sorumlunun aÃ§Ä±kÃ§a
gÃ¶rÃ¼lebilmesi aÃ§Ä±sÄ±ndan <code>MAINTAINER</code> satÄ±rÄ±nÄ± kullanmanÄ±z iyi olur.</p><p><code>ADD</code> komutuyla, bulunduÄŸum dizini container&rsquo;Ä±n <code>/srv</code> dizinine kopyalÄ±yorum. UygulamamÄ± bu dizinde tutuyor olacaÄŸÄ±m.
Bu tercih tamamen size kalmÄ±ÅŸ. Ä°sterseniz <code>/app</code> vb. bir dizin de kullanabilirsiniz. Ya da Tomcat imajÄ±nÄ± baz
alÄ±yorsanÄ±z doÄŸrudan uygulamanÄ±zÄ± <code>/usr/share/tomcat/webapps</code> gibi bir dizin altÄ±na da kopyalayabilirsiniz. Bir sonraki
satÄ±rda (<code>WORKDIR</code>) ise bundan sonraki komutlarÄ±n Ã§alÄ±ÅŸtÄ±rÄ±lacaÄŸÄ± dizini <code>/srv</code> olarak belirtiyorum.</p><blockquote><p>Dockerfileâ€™daki her satÄ±r diÄŸer komutlardan baÄŸÄ±msÄ±z Ã§alÄ±ÅŸÄ±r. <code>WORKDIR /srv</code> yerine <code>cd /srv</code> yazarsanÄ±z bu sonraki
komutlarÄ±n yine <code>/</code> dizininde Ã§alÄ±ÅŸmasÄ±na sebep olacaktÄ±r.</p></blockquote><p>Serinin ilk bÃ¶lÃ¼mÃ¼ndeki &ldquo;<a href=https://alperkan.at/tr/2016/07/docker-serisi-1/#imaj-ne-demek>Ä°maj ne demek?</a>&rdquo; kÄ±smÄ±nda bahsettiÄŸim gibi,
Docker imajlarÄ± katmanlardan oluÅŸur. Dockerfileâ€™da yazdÄ±ÄŸÄ±nÄ±z, imaja bir ÅŸey ekleyen (<code>ADD</code>, <code>COPY</code>, <code>RUN</code> vb.) her
satÄ±r, imaja yeni bir katman ekler; dolayÄ±sÄ±yla boyutunu artÄ±rÄ±r. Bu nedenle, dosyanÄ±n yukarÄ±dan aÅŸaÄŸÄ±ya doÄŸru
okunduÄŸunu unutmayarak, deÄŸiÅŸmeyecek kÄ±sÄ±mlarÄ± mÃ¼mkÃ¼n olduÄŸunca yukarÄ±ya eklemeli ve komutlarÄ± zincirlemelisiniz. 8.
satÄ±rdaki <code>apt</code> komutlarÄ±nÄ±n zincirlenmesi, iÅŸletim sistemi gÃ¼ncellemelerinin tek bir katmanda yer almasÄ±nÄ± saÄŸlÄ±yor.</p><p>9â€“12. satÄ±rlar arasÄ±nda uygulamanÄ±n Ã§alÄ±ÅŸmasÄ± iÃ§in gereken baÄŸÄ±mlÄ±lÄ±klarÄ± kurup (<code>RUN</code>), uygulamayÄ± derliyoruz.</p><ol start=14><li><p>satÄ±rda <code>NODE_ENV</code> adÄ±nda bir Ã§evresel deÄŸiÅŸken tanÄ±mlayÄ±p (<code>NODE_ENV</code>) Ã¶ntanÄ±mlÄ± deÄŸerini <code>production</code> yapÄ±yoruz.
Bu, yukarÄ±da bahsettiÄŸim gerÃ§ek ortama yÃ¶nelik imaj oluÅŸturma prensibiyle de Ã¶rtÃ¼ÅŸÃ¼yor. Ã‡alÄ±ÅŸma zamanÄ±nda
<code>-e NODE_ENV=development</code> parametresiyle Ã¶ntanÄ±mlÄ± deÄŸeri ezebiliyoruz.</p></li><li><p>satÄ±rda, 3000. baÄŸlantÄ± noktasÄ±nÄ±n dÄ±ÅŸarÄ±dan kullanÄ±labileceÄŸini (<code>EXPOSE</code>) belirtiyorum. YukarÄ±da belirttiÄŸim
gibi, Ã§alÄ±ÅŸma zamanÄ±nda <code>-p 3000:3000</code> ya da <code>-P</code> gibi bir parametreyle bu baÄŸlantÄ± noktasÄ±nÄ± ev sahibi makineye
baÄŸlamam gerekiyor.</p></li></ol><p>Son olarak 17. satÄ±rdaki <code>CMD</code> komutuyla Ã¶ntanÄ±mlÄ± olarak, daha Ã¶nce <code>WORKDIR</code> ile belirlediÄŸimiz dizindeki (<code>/srv</code>)
<code>app.js</code> dosyasÄ±nÄ±n Ã§alÄ±ÅŸtÄ±rÄ±lacaÄŸÄ±nÄ± belirtiyoruz. Bu satÄ±rda <code>CMD</code> yerine <code>ENTRYPOINT</code> kullanarak da aynÄ± iÅŸi
yapabilirdik ama CMD daha esnek olduÄŸundan onu tercih edebiliriz. Serinin
<a href=https://alperkan.at/tr/2016/09/docker-serisi-2/#docker-run->ikinci bÃ¶lÃ¼mÃ¼nde</a> bahsettiÄŸim gibi <code>docker run</code> komutlarÄ±nÄ±n sonunda <code>cat</code>
vb. terminal komutlarÄ±nÄ± Ã§aÄŸÄ±rabiliyoruz. Bunu <code>CMD</code>â€™e borÃ§luyuz. <code>ENTRYPOINT</code> kullanÄ±yor olsaydÄ±k, imaj iÃ§in
belirlenen komut dÄ±ÅŸÄ±nda bir komutu Ã§aÄŸÄ±ramÄ±yor olacaktÄ±k.</p><p>Dockerfileâ€™la ilgili bu kÄ±smÄ± diÄŸer kullanÄ±ÅŸlÄ± bazÄ± komutlarÄ± aÃ§Ä±klayarak kapatayÄ±m:</p><h4 id=label>LABEL<a hidden class=anchor aria-hidden=true href=#label>#</a></h4><p>OluÅŸturulacak imajÄ±n sahip olacaÄŸÄ± Ã¶ntanÄ±mlÄ± etiketleri belirler. Ã–lÃ§eklenebilirliÄŸin Ã¶nemli olduÄŸu durumlarda
<code>docker run</code> ile etiket vermektense bu ÅŸekilde etiketler tanÄ±mlamak daha mantÄ±klÄ± ve kolay.</p><pre tabindex=0><code>LABEL type=&#34;node&#34; purpose=&#34;api&#34; role=&#34;core&#34; description=&#34;REST API&#34;
</code></pre><h4 id=volume>VOLUME<a hidden class=anchor aria-hidden=true href=#volume>#</a></h4><p>YukarÄ±daki <a href=#kalÄ±cÄ±-veri-depolama>KalÄ±cÄ± Veri Depolama</a> kÄ±smÄ±nda bahsettiÄŸim gibi containerâ€™lara
dÄ±ÅŸarÄ±dan disk alanlarÄ± baÄŸlayabiliyoruz. Dockerfileâ€™a ekleyeceÄŸiniz <code>VOLUME</code> komutlarÄ±yla container iÃ§indeki disk
alanlarÄ±nÄ±n dÄ±ÅŸarÄ±dan baÄŸlanabileceÄŸini belirtmiÅŸ oluyorsunuz.</p><pre tabindex=0><code>VOLUME [â€œ/dataâ€]
VOLUME /data
</code></pre><h4 id=user>USER<a hidden class=anchor aria-hidden=true href=#user>#</a></h4><p>Container iÃ§inde Ã§alÄ±ÅŸan sÃ¼reÃ§ler siz aksini belirtmediÄŸiniz sÃ¼rece <code>root</code> kullanÄ±cÄ±sÄ±yla Ã§alÄ±ÅŸtÄ±rÄ±lÄ±r. Bu da
Dockerâ€™daki olasÄ± bir aÃ§Ä±ÄŸÄ±n kÃ¶tÃ¼ye kullanÄ±lmasÄ±yla istenmeyen sonuÃ§lara sebebiyet verebilir. Bu tip durumlarÄ±n Ã¶nÃ¼ne
geÃ§mek iÃ§in Ã¶zellikle proje baÄŸÄ±mlÄ±lÄ±klarÄ±nÄ± kurmadan Ã¶nce <code>USER</code> komutunu vermiÅŸ olmanÄ±z iyi olur. Bu sayede
baÄŸÄ±mlÄ±lÄ±klarÄ±n dosya/dizin sahipliÄŸi de bu kullanÄ±cÄ±ya ait olur.</p><h4 id=arg>ARG<a hidden class=anchor aria-hidden=true href=#arg>#</a></h4><p>Ã‡evresel durumlarÄ±n yetiÅŸmediÄŸi bazÄ± durumlarda imajlarÄ±nÄ±zÄ± parametrik Ã¼retmek isterseniz <code>ARG</code> komutuyla deÄŸiÅŸkenler
ve Ã¶ntanÄ±mlÄ± deÄŸerlerini tanÄ±mlayabilirsiniz. Bu tanÄ±mlar <code>docker build</code> komutunda, imajÄ±nÄ±z yaratÄ±lÄ±rken kullanÄ±lÄ±r.</p><pre tabindex=0><code>ARG user1=someuser
ARG buildno=1
</code></pre><p>ÅŸeklinde deÄŸiÅŸkenler tanÄ±mladÄ±ÄŸÄ±nÄ±zÄ± varsayarsak; Ã¶rneÄŸin buildnoâ€™yu imaj oluÅŸturulurken deÄŸiÅŸtirmek isterseniz:</p><pre tabindex=0><code>docker build --build-arg buildno=2 -t tunix/alperkan.at .
</code></pre><p>ÅŸeklinde yapabilirsiniz.</p><h4 id=healthcheck>HEALTHCHECK<a hidden class=anchor aria-hidden=true href=#healthcheck>#</a></h4><p>Docker 1.12 ile eklenen <a href=https://docs.docker.com/engine/reference/builder/#/healthcheck>bu Ã¶zellik</a> sayesinde
containerâ€™Ä±n olmasÄ± gerektiÄŸi gibi Ã§alÄ±ÅŸÄ±p Ã§alÄ±ÅŸmadÄ±ÄŸÄ±nÄ± kontrol eden bir komutun belirli sÄ±klÄ±kta ve belirli zaman
dilimlerinde Ã§alÄ±ÅŸmasÄ±nÄ± saÄŸlayabilirsiniz. Bu metrikleri takip eden baÅŸka servislerle yeni bir container
baÅŸlatÄ±lmasÄ±nÄ±, mevcut containerâ€™Ä±n yeniden baÅŸlatÄ±lmasÄ±nÄ± saÄŸlayabilir ya da Ã§eÅŸitli alarm sistemlerini
tetikleyebilirsiniz.</p><pre tabindex=0><code>HEALTHCHECK --interval=5m --timeout=3s \
CMD curl -f http://localhost/ || exit 1
</code></pre><h3 id=kendi-imajÄ±nÄ±zÄ±-hazÄ±rlamak>Kendi Ä°majÄ±nÄ±zÄ± HazÄ±rlamak<a hidden class=anchor aria-hidden=true href=#kendi-imajÄ±nÄ±zÄ±-hazÄ±rlamak>#</a></h3><p>Diyelim ki elinizde, Dockerâ€™laÅŸtÄ±rmak istediÄŸiniz bir projeniz var; ne yapmalÄ±sÄ±nÄ±z? Bu sorunun cevabÄ±nÄ± vermek iÃ§in
<a href="https://medium.com/u/f570294a852c?source=post_page-----a7c6c5f50851--------------------------------">Monitise MEA</a>â€™da
aÃ§Ä±k kaynak olarak GitHubâ€™a koyduÄŸumuz
<a href=https://github.com/monitise-mea/gerrit-dashboard-server>Gerrit Dashboard Server</a> projesini Ã¶rnek olarak kullanacaÄŸÄ±m.</p><p>Projeyi kendi makinenize indirdikten sonra;</p><pre tabindex=0><code>npm install
gulp
</code></pre><p>komutlarÄ±yla baÄŸÄ±mlÄ±lÄ±klarÄ± kurup projeyi derleyin. Son komutla, <a href=https://nodejs.org/en/>Node.js</a> ile yazÄ±lmÄ±ÅŸ
projenin derlenmiÅŸ hali <code>dist</code> dizinine yerleÅŸtiriliyor. Bu dizini,
<a href=https://store.docker.com/images/e6658267-cc55-421e-b5be-5e69460fb0d1>node</a> imajlarÄ±ndan birini baz alan bir
containerâ€™Ä±n iÃ§ine kopyalayÄ±p Ã§alÄ±ÅŸtÄ±rmalÄ±yÄ±m.
<a href=https://github.com/monitise-mea/gerrit-dashboard-server/blob/master/Dockerfile>Dockerfile</a>â€™a bakarsak;</p><script type=application/javascript src=https://gist.github.com/tunix/b8e1e76ffbfd6a0f2408dea843411e1f.js></script><p>Gerrit Dashboard Server projesinden Docker imajÄ± Ã¼retme iÅŸini Travis CI Ã¼stÃ¼nde
<a href=https://travis-ci.org/monitise-mea/gerrit-dashboard-server>yapÄ±yoruz</a>. Ã–ncelikle imajÄ±n doÄŸru ÅŸekilde Ã¼retildiÄŸinden
emin olmak iÃ§in kendi makinemizde kurulu olan Docker Engine Ã¼stÃ¼nde deneyelim:</p><pre tabindex=0><code>docker build -t gerrit-dashboard-server:1.0.2 .
</code></pre><p>Ä°ÅŸlem baÅŸarÄ±lÄ± bir ÅŸekilde sonuÃ§landÄ±ÄŸÄ±nda <code>docker images</code> komutunu verdiÄŸinizde imajÄ±n oluÅŸturulduÄŸunu
doÄŸrulayabilmelisiniz.</p><blockquote><p>Ä°majÄ± daÄŸÄ±tÄ±ma Ã§Ä±karmadan Ã¶nce kullanÄ±labilecek parametrelerle birlikte doÄŸru ÅŸekilde Ã§alÄ±ÅŸtÄ±ÄŸÄ±ndan emin olun.</p></blockquote><p>OluÅŸturduÄŸunuz imajÄ± baÅŸka bir makineye kopyalamak iÃ§in 2 seÃ§eneÄŸiniz var:</p><ul><li>Docker Engineâ€™den arÅŸivlenmiÅŸ ÅŸekilde dÄ±ÅŸa aktarmak</li><li>Docker Store benzeri bir servise yÃ¼klemek</li></ul><p>Docker Engineâ€™den arÅŸivlenmiÅŸ ÅŸekilde dÄ±ÅŸa aktarmak iÃ§in;</p><pre tabindex=0><code>docker save -o ~/Desktop/gerritdashboard-1.0.2.tar \
    gerrit-dashboard-server:1.0.2
</code></pre><p>komutunu kullanabilirsiniz. OluÅŸan tar dosyasÄ±nÄ± diÄŸer makineye kopyaladÄ±ktan sonra yeniden iÃ§eri aktarÄ±m yapmak iÃ§inse;</p><pre tabindex=0><code>docker load -i gerritdashboard-1.0.2.tar
</code></pre><p>komutunu kullanabilirsiniz.</p><h3 id=docker-store--registry>Docker Store & Registry<a hidden class=anchor aria-hidden=true href=#docker-store--registry>#</a></h3><p>Docker imajlarÄ±nÄ± saklamanÄ±n en kolay yollarÄ±ndan birisi <a href=https://store.docker.com/>Docker Store</a>â€™a yÃ¼klemek.
Ã‡oÄŸunlukla baz imajlarÄ± indirmek iÃ§in en temel kaynak olarak kullandÄ±ÄŸÄ±mÄ±z <a href=https://hub.docker.com/>Docker Hub</a> (yeni
adÄ±yla <a href=https://store.docker.com/>Docker Store</a>) aslÄ±nda kendi imajlarÄ±mÄ±za da ev sahipliÄŸi yapabilecek bir depo.
Genele aÃ§Ä±k imajlarÄ±nÄ±zÄ± sÄ±nÄ±rsÄ±zca yÃ¼kleyebileceÄŸiniz servis, Ã¶zel imajlarÄ±nÄ±z iÃ§in 5 adede kadar Ã¼cretsiz olanak
saÄŸlÄ±yor. SonrasÄ± iÃ§inse <a href=https://hub.docker.com/billing-plans/>Ã¼cretli Ã¼yeliklerden</a> birine geÃ§ilmesi gerekiyor.</p><p>EÄŸer oluÅŸturduÄŸunuz imajÄ± herkese aÃ§Ä±k olarak yÃ¼klemenizde bir sakÄ±nca yoksa <a href=https://hub.docker.com/>Docker Hub</a>â€™a
Ã¼cretsiz olarak yÃ¼kleyebilirsiniz. Bunun iÃ§in Ã¶ncelikle servise kayÄ±t olmalÄ±sÄ±nÄ±z. KayÄ±t olduktan sonra kullanÄ±cÄ±
bilgilerinizle giriÅŸ yapÄ±n ve yeni bir Docker imaj deposu (repository) oluÅŸturun. Bunun iÃ§in tercih edebileceÄŸiniz 2
yol var:</p><h4 id=manuel-depo>Manuel Depo<a hidden class=anchor aria-hidden=true href=#manuel-depo>#</a></h4><figure><img loading=lazy src=docker_hub_manuel_repo.png alt="Docker Hubâ€™da manuel depo oluÅŸturma formu"><figcaption><p>Docker Hubâ€™da manuel depo oluÅŸturma formu</p></figcaption></figure><p>GiriÅŸ yaptÄ±ktan sonra saÄŸ Ã¼stteki Create menÃ¼sÃ¼nden Create Repositoryâ€™e basÄ±n. Formdaki alanlarÄ± doldurduktan sonra
Create tuÅŸuna basÄ±n. Åimdi imajÄ± yÃ¼kleme zamanÄ±! ğŸ¤˜ğŸ»</p><p>YÃ¼kleme yapabilmek iÃ§in bilgisayarÄ±nÄ±zdan Docker Hubâ€™a giriÅŸ yapmak iÃ§in;</p><pre tabindex=0><code>docker login
</code></pre><p>komutunu verin. E-posta adresinizi ve ÅŸifrenizi yazÄ±p doÄŸrulamadan geÃ§tikten sonra ev dizininizdeki
<code>~/.docker/config.json</code> dosyasÄ±na ilgili servise ait giriÅŸ bilgileri (yetki kodu ve e-posta adresiniz) yazÄ±lacaktÄ±r.
Bu iÅŸlem, aynÄ± servisi kullandÄ±ÄŸÄ±nÄ±z sÃ¼rece tek seferliktir; tekrarlamanÄ±z gerekmez.</p><p>Yukardaki son <a href=#kendi-imajÄ±nÄ±zÄ±-hazÄ±rlamak>Ã¶rneÄŸimizden</a> devam edelim. Ä°majÄ±mÄ±zÄ±
<code>gerrit-dashboard-server:1.0.2</code> adÄ±yla oluÅŸturmuÅŸtuk. Docker Engine, imajÄ± uzaktaki bir servise yÃ¼kleyeceÄŸimizde nereye
yÃ¼kleyeceÄŸini imajÄ±n adÄ±ndan <a href=https://alperkan.at/tr/2016/09/docker-serisi-2/#docker-push-registrygitlabcomtunixalperkanat105>buluyor</a>.
Bu nedenle imajÄ± yeniden oluÅŸturmamÄ±za gerek yok; etiketleri kullanarak iÅŸlemi gerÃ§ekleÅŸtirebiliriz. Docker Hub servisi
iÃ§in imajÄ± etiketleyelim:</p><pre tabindex=0><code>docker tag gerrit-dashboard-server:1.0.2 docker.io/tunix/gerritdashboard-server:1.0.2
</code></pre><p>ArtÄ±k imajÄ± Docker Hubâ€™a yÃ¼kleyebiliriz:</p><pre tabindex=0><code>docker push docker.io/tunix/gerritdashboard-server:1.0.2
</code></pre><p>Ä°ÅŸlem node imajÄ±nÄ± baz alÄ±p Ã¼stÃ¼ne sadece kendi katmanlarÄ±mÄ±zÄ± eklediÄŸimizden hÄ±zlÄ±ca tamamlanacaktÄ±r. ArtÄ±k Docker
Engine yÃ¼klÃ¼ olan herhangi bir makinede;</p><pre tabindex=0><code>docker pull docker.io/tunix/gerritdashboard-server:1.0.2
</code></pre><p>komutuyla imajÄ± indirip kullanmaya baÅŸlayabilirsiniz.</p><h4 id=otomatik-depo>Otomatik Depo<a hidden class=anchor aria-hidden=true href=#otomatik-depo>#</a></h4><figure><img loading=lazy src=docker_hub_otomatik_depo.png alt="Docker Hubâ€™da otomatik depo oluÅŸturma formu"><figcaption><p>Docker Hubâ€™da otomatik depo oluÅŸturma formu</p></figcaption></figure><p>GiriÅŸ yaptÄ±ktan sonra saÄŸ Ã¼stteki Create menÃ¼sÃ¼nden Create Automated Buildâ€™a basÄ±n. KarÅŸÄ±nÄ±za yukarÄ±daki gibi GitHub
ya da Bitbucket arasÄ±nda seÃ§im yapmanÄ±z gereken bir ekran gelecek. SeÃ§iminizi yaptÄ±ÄŸÄ±nÄ±zda ilgili servisin sitesine
gidip kod depolarÄ±nÄ±za eriÅŸim hakkÄ± vermeniz gerekecektir. Bu adÄ±mÄ± gerÃ§ekleÅŸtirdikten sonra kod depolarÄ±nÄ±zÄ± seÃ§meniz
iÃ§in aÅŸaÄŸÄ±daki gibi bir ekran gÃ¶receksiniz:</p><figure><img loading=lazy src=docker_hub_repo_secimi.png alt="GitHub kod depolarÄ±nÄ± listeleyen sayfadan istediÄŸinizi seÃ§in"><figcaption><p>GitHub kod depolarÄ±nÄ± listeleyen sayfadan istediÄŸinizi seÃ§in</p></figcaption></figure><p>SeÃ§iminizi yaptÄ±ÄŸÄ±nÄ±zda karÅŸÄ±nÄ±za otomatik depo oluÅŸturmanÄ±n son adÄ±mÄ± olan form Ã§Ä±kacaktÄ±r; formu doldurup Create
tuÅŸuna bastÄ±ÄŸÄ±nÄ±zda deponuz oluÅŸturulacak ve ilk derleme iÅŸlemi iÃ§in beklemeye baÅŸlayacaktÄ±r. AslÄ±nda kod deposu
seÃ§imini yaptÄ±ÄŸÄ±nÄ±zda arkaplanda seÃ§im yaptÄ±ÄŸÄ±nÄ±z depoya bir webhook (aÄŸ kancasÄ±? ğŸ˜‚) eklenir. Kod deposuna yeni kod
parÃ§acÄ±ÄŸÄ± gÃ¶nderdiÄŸinizde Docker Hubâ€™da otomatik olarak bir derlenme sÃ¼reci tetiklenecek ve oluÅŸturulan imajÄ±nÄ±z
sayfada yer alacaktÄ±r.</p><figure><img loading=lazy src=docker_hub_proje_sayfasi.png alt="GitHubâ€™daki digitalocean-dyndns adlÄ± projemin Docker imajlarÄ± Docker Hub tarafÄ±ndan otomatik oluÅŸturuluyor."><figcaption><p>GitHubâ€™daki digitalocean-dyndns adlÄ± projemin Docker imajlarÄ± Docker Hub tarafÄ±ndan otomatik oluÅŸturuluyor.</p></figcaption></figure><h4 id=docker-registry>Docker Registry<a hidden class=anchor aria-hidden=true href=#docker-registry>#</a></h4><p>Docker Hub bu servisi verirken arkaplanda <a href=https://github.com/docker/docker-registry>Docker Registry</a> (yeni adÄ±yla
<a href=https://github.com/docker/distribution>Docker Distribution</a>) adÄ± verilen aÃ§Ä±k kaynak kodlu bir yazÄ±lÄ±mÄ± kullanÄ±yor.
EÄŸer imajlarÄ±nÄ±zÄ± yÃ¼klemek iÃ§in bir registryâ€™e para vermek istemiyorsanÄ±z kendi registryâ€™nizi kurabilirsiniz. Ancak
bÃ¶yle bir tercihte bulunacaksanÄ±z kurulum yapacaÄŸÄ±nÄ±z sunucunun yÃ¶netimini ve maliyetlerini de gÃ¶z Ã¶nÃ¼nde bulundurun.
Ã–te yandan proje kodlarÄ±nÄ± git vb. bir SKS (sÃ¼rÃ¼m kontrol sistemi) Ã¼stÃ¼nde tuttuÄŸunuz sÃ¼rece geriye dÃ¶nÃ¼p imajÄ± yeniden
yaratmanÄ±z mÃ¼mkÃ¼n olabileceÄŸinden riskiniz o kadar da yÃ¼ksek deÄŸil. Yine de kodunuzun o anki hali deÄŸilse bile
bulunduÄŸu ortamÄ±n ve baÄŸÄ±mlÄ±lÄ±klarÄ±n sÄ±kÄ±ntÄ± Ã§Ä±karabileceÄŸini unutmayÄ±n. ğŸ¤”</p><h3 id=kendi-docker-registrynizi-kurun>Kendi Docker Registry&rsquo;nizi Kurun<a hidden class=anchor aria-hidden=true href=#kendi-docker-registrynizi-kurun>#</a></h3><p><a href="https://medium.com/u/f570294a852c?source=post_page-----a7c6c5f50851--------------------------------">Monitise MEA</a>â€™da
hibrid bir geliÅŸtirme ve test ortamÄ±mÄ±z var. Klasik ÅŸekilde bir VM Ã¼stÃ¼ne kurulu Tomcatâ€™e yÃ¼klenen sayÄ±sÄ±z projemiz
olduÄŸu gibi, yeni projelerimizde Dockerâ€™Ä± kullanma seÃ§eneÄŸini her zaman gÃ¶z Ã¶nÃ¼nde bulunduruyoruz. GerÃ§ek ortamda
Dockerâ€™Ä± hiÃ§ kullanmayan projelerde dahi bazÄ± durumlarda geliÅŸtirme ve test ortamÄ± iÃ§in Dockerâ€™Ä± tercih edebiliyoruz.
DolayÄ±sÄ±yla bu projelerin Docker imajlarÄ±nÄ± Ã¼retmemiz ve sunucular arasÄ±nda taÅŸÄ±maya ihtiyacÄ±mÄ±z var ve Docker Registry
burada devreye giriyor.</p><p>Ã–zetle, Docker Registry bir APIâ€™dan ve disk Ã¼stÃ¼nde imaj katmanlarÄ±nÄ± yÃ¶neten bir sistemden oluÅŸuyor. API v1 iken
<a href=https://github.com/docker/docker-registry>Docker Registry</a> adÄ±nÄ± taÅŸÄ±rken, v2 ile birlikte
<a href=https://github.com/docker/distribution>Docker Distribution</a> adÄ±nÄ± aldÄ±. Her ikisi de Docker Storeâ€™dan
<a href=https://store.docker.com/images/d93c7069-a612-4019-ade6-8c3b0a73acd9>indirilebilir durumda</a>. Kurmak iÃ§in;</p><pre tabindex=0><code>docker run -d -p 5000:5000 --name registry registry:2
</code></pre><p>komutunu vermeniz yeterli. Bu durumda aÅŸaÄŸÄ±daki Ã¶ntanÄ±mlÄ± deÄŸerler geÃ§erli olur:</p><ul><li>Ä°majlarÄ±nÄ±z container iÃ§indeki <code>/var/lib/registry</code> dizini altÄ±na yazÄ±lÄ±r. Ã–ntanÄ±mlÄ± olarak filesystem sÃ¼rÃ¼cÃ¼sÃ¼
kullanÄ±lÄ±r. Alternatifler <a href=https://docs.docker.com/registry/storage-drivers/>ÅŸurada</a>.</li><li>Registryâ€™nize, herhangi bir SSL sertifikasÄ±na sahip olmadÄ±ÄŸÄ±ndan, HTTP Ã¼stÃ¼nden ulaÅŸÄ±rsÄ±nÄ±z.</li><li>Registryâ€™niz herkesin yÃ¼klemesine ve indirmesine aÃ§Ä±k ÅŸekilde Ã§alÄ±ÅŸÄ±r; kullanÄ±cÄ±larÄ±n Ã¶nce giriÅŸ yapmalarÄ± gerekmez.
KullandÄ±ÄŸÄ±nÄ±z aÄŸÄ±n dÄ±ÅŸarÄ±ya aÃ§Ä±k olmamasÄ± durumunda bu ÅŸekilde de Ã§alÄ±ÅŸabilirsiniz.</li></ul><p>Registry kurulumuyla ilgili en gÃ¼ncel bilgiyi <a href=https://docs.docker.com/registry/deploying/>ÅŸuradan</a> bulabilirsiniz.
Benim tavsiyem; registry iÃ§in ev sahibi makineye ek disk vermeniz ve containerâ€™daki <code>/var/lib/registry</code> dizinini ev
sahibi makinedeki <code>/registry</code> dizinine baÄŸlamanÄ±z yÃ¶nÃ¼nde. AyrÄ±ca registryâ€™i kullanan tÃ¼m makinelerde ek ayar
(<code>--insecure-registry</code>) yapmamak iÃ§in sunucuya geÃ§erli bir sertifika kurmanÄ±zda fayda var.
<a href=https://letsencrypt.org/>LetsEncrypt</a> gibi gÃ¼zelliklerin olduÄŸu gÃ¼nÃ¼mÃ¼zde yapmazsanÄ±z ayÄ±p! ğŸ˜‰ Tabii sertifika iÅŸini
registryâ€™nin Ã¶nÃ¼ne bir HTTP sunucusu (<a href=https://nginx.org/>nginx</a>, <a href=http://httpd.apache.org/>Apache</a> vb.) koyarak da
Ã§Ã¶zebilirsiniz. Hatta HTTP sunucusu yerine <a href=https://hub.docker.com/r/yajo/https-proxy/>https-proxy</a>â€™i de
kullanabilirsiniz.</p><p>Son durumda registry kurulumu iÃ§in aÅŸaÄŸÄ±daki gibi bir komuta ihtiyacÄ±nÄ±z var:</p><pre tabindex=0><code>docker run -d --name registry \
    -p 5000:5000 \
    --restart=always \
    -v /registry:/var/lib/registry \
    registry:2
</code></pre><p><a href=https://hub.docker.com/r/yajo/https-proxy/>https-proxy</a> kullanmak isteyenlere bonus olarak Ã¶rnek komutu ekleyeyim:</p><pre tabindex=0><code>docker run -d --name registry-ssl \
    -e KEY=â€$(cat registry.key)â€ \
    -e CERT=â€$(cat registry.crt)â€ \
    -p 443:443 \
    -e PORT=5000 \
    --restart=always \
    --link registry:www \
    yajo/https-proxy
</code></pre><blockquote><p>registry containerâ€™Ä±nÄ± yaratÄ±rken kullandÄ±ÄŸÄ±nÄ±z ismin, https-proxyâ€™i yaratÄ±rken kullandÄ±ÄŸÄ±nÄ±z komuttaki &ndash;link
bÃ¶lÃ¼mÃ¼ndeki registry ismiyle aynÄ± olduÄŸundan emin olun.</p></blockquote><p>Diyelim ki; registryâ€™inize ulaÅŸtÄ±ÄŸÄ±nÄ±z adres <code>docker.example.com</code> olsun. Bu durumda imajlarÄ±nÄ±zÄ± buraya yÃ¼klemek iÃ§in
<code>docker.example.com/tunix/alperkan.at:1.0.2</code> gibi isimlendirmelisiniz. <code>docker push</code> komutuyla imajÄ±nÄ±zÄ± yÃ¼klerken,
Docker Engine otomatik olarak HTTPS protokolÃ¼nÃ¼ tercih edecektir. Bu nedenle SSL adÄ±mÄ±nÄ± atladÄ±ysanÄ±z ve kendi
makinenizden yÃ¼kleme yapÄ±yorsanÄ±z Docker Engine ayarlarÄ±nda yeni registryâ€™inizi &ldquo;Insecure Registries&rdquo; bÃ¶lÃ¼mÃ¼nden
ekleyin. Linuxâ€™da bu arayÃ¼z geliyor mu emin deÄŸilim ama <a href=https://docs.docker.com/registry/insecure/>ÅŸuradaki adÄ±mlarÄ±</a>
takip edebilirsiniz.</p><figure><img loading=lazy src=docker_for_mac_advanced_tab.png></figure><hr><p>Bu bÃ¶lÃ¼mÃ¼nÃ¼n de sonuna geldik. Bir sonraki bÃ¶lÃ¼mde Docker Composeâ€™dan ve Ã¶zellikle birden fazla parÃ§aya ihtiyaÃ§ duyan
projelerinizi Docker ile nasÄ±l kolayca ayaÄŸa kaldÄ±rabileceÄŸinizden bahsedeceÄŸim.</p><p>GidiÅŸÃ¢ta gÃ¶re bu planda zaman zaman deÄŸiÅŸiklikler yapacak olsam da serinin tÃ¼m bÃ¶lÃ¼mlerinin planÄ±na
<a href=https://www.evernote.com/l/AB7CctYtJkpMUJsae1_3FgzIXgMY5MvFQhU>ÅŸuradan</a> ulaÅŸabilirsiniz.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://alperkan.at/tr/tags/yaz%C4%B1l%C4%B1m/>yazÄ±lÄ±m</a></li><li><a href=https://alperkan.at/tr/tags/docker/>docker</a></li><li><a href=https://alperkan.at/tr/tags/docker-serisi/>docker serisi</a></li><li><a href=https://alperkan.at/tr/tags/container/>container</a></li><li><a href=https://alperkan.at/tr/tags/sanalla%C5%9Ft%C4%B1rma/>sanallaÅŸtÄ±rma</a></li><li><a href=https://alperkan.at/tr/tags/linux/>linux</a></li><li><a href=https://alperkan.at/tr/tags/devops/>devops</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://alperkan.at/tr/>Alper Kanat</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById("menu");menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>