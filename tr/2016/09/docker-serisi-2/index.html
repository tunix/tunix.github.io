<!doctype html><html lang=tr dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Docker Serisi #2 -- Docker Engine Bölüm 1 | Alper Kanat</title><meta name=keywords content="yazılım,docker,docker serisi,container,sanallaştırma,linux,devops"><meta name=description content="Docker Serisi’nin ilk bölümünde sanallaştırmanın ne olduğundan, container teknolojisinden ve temel Docker kavramlarından bahsetmiştim. Serinin bu bölümünde temel Docker komutlarının kullanılmasından bahsedeceğim. Hazırsanız başlayalım! 🙂
docker <cmd> &mldr; Öncelikle tüm docker komutları docker kelimesiyle başlıyor. Serinin sonraki bölümlerinde bahsedeceğim eklentiler ise docker- ön ekiyle (docker-compose, docker-swarm gibi..) başlıyorlar. Hiç bir parametre vermeden yalnızca bu komutları yazacak olursanız ilgili komuta ait yardım metinleri ekranınıza çıkacaktır. Dolayısıyla docker’ı ya da eklentilerini kurduktan sonra, kurulumunuzun başarılı olduğunu anlamak için ilk yapmanız gereken şey herhangi bir parametre vermeden çalıştırdığınızda yardım metinlerini görüp göremediğiniz olmalı."><meta name=author content><link rel=canonical href=https://alperkan.at/tr/2016/09/docker-serisi-2/><link crossorigin=anonymous href=/assets/css/stylesheet.min.2d6dbfc6e0f8a1db1c9d082a76dc11d094328cf63f247bbc2421dfaa7f2bb170.css integrity="sha256-LW2/xuD4odscnQgqdtwR0JQyjPY/JHu8JCHfqn8rsXA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://alperkan.at/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://alperkan.at/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://alperkan.at/favicon-32x32.png><link rel=apple-touch-icon href=https://alperkan.at/apple-touch-icon.png><link rel=mask-icon href=https://alperkan.at/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.102.3"><link rel=alternate hreflang=tr href=https://alperkan.at/tr/2016/09/docker-serisi-2/><script async src="https://www.googletagmanager.com/gtag/js?id=G-SDT9Y68PM3"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-SDT9Y68PM3",{anonymize_ip:!1})}</script><meta property="og:title" content="Docker Serisi #2 -- Docker Engine Bölüm 1"><meta property="og:description" content="Docker Serisi’nin ilk bölümünde sanallaştırmanın ne olduğundan, container teknolojisinden ve temel Docker kavramlarından bahsetmiştim. Serinin bu bölümünde temel Docker komutlarının kullanılmasından bahsedeceğim. Hazırsanız başlayalım! 🙂
docker <cmd> &mldr; Öncelikle tüm docker komutları docker kelimesiyle başlıyor. Serinin sonraki bölümlerinde bahsedeceğim eklentiler ise docker- ön ekiyle (docker-compose, docker-swarm gibi..) başlıyorlar. Hiç bir parametre vermeden yalnızca bu komutları yazacak olursanız ilgili komuta ait yardım metinleri ekranınıza çıkacaktır. Dolayısıyla docker’ı ya da eklentilerini kurduktan sonra, kurulumunuzun başarılı olduğunu anlamak için ilk yapmanız gereken şey herhangi bir parametre vermeden çalıştırdığınızda yardım metinlerini görüp göremediğiniz olmalı."><meta property="og:type" content="article"><meta property="og:url" content="https://alperkan.at/tr/2016/09/docker-serisi-2/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2016-09-26T00:00:00+00:00"><meta property="article:modified_time" content="2021-04-25T00:40:03+03:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Docker Serisi #2 -- Docker Engine Bölüm 1"><meta name=twitter:description content="Docker Serisi’nin ilk bölümünde sanallaştırmanın ne olduğundan, container teknolojisinden ve temel Docker kavramlarından bahsetmiştim. Serinin bu bölümünde temel Docker komutlarının kullanılmasından bahsedeceğim. Hazırsanız başlayalım! 🙂
docker <cmd> &mldr; Öncelikle tüm docker komutları docker kelimesiyle başlıyor. Serinin sonraki bölümlerinde bahsedeceğim eklentiler ise docker- ön ekiyle (docker-compose, docker-swarm gibi..) başlıyorlar. Hiç bir parametre vermeden yalnızca bu komutları yazacak olursanız ilgili komuta ait yardım metinleri ekranınıza çıkacaktır. Dolayısıyla docker’ı ya da eklentilerini kurduktan sonra, kurulumunuzun başarılı olduğunu anlamak için ilk yapmanız gereken şey herhangi bir parametre vermeden çalıştırdığınızda yardım metinlerini görüp göremediğiniz olmalı."><script type=application/ld+json>
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://alperkan.at/tr/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Docker Serisi #2 -- Docker Engine Bölüm 1",
      "item": "https://alperkan.at/tr/2016/09/docker-serisi-2/"
    }
  ]
}
</script><script type=application/ld+json>
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Docker Serisi #2 -- Docker Engine Bölüm 1",
  "name": "Docker Serisi #2 -- Docker Engine Bölüm 1",
  "description": "Docker Serisi’nin ilk bölümünde sanallaştırmanın ne olduğundan, container teknolojisinden ve temel Docker kavramlarından bahsetmiştim. Serinin bu bölümünde temel Docker komutlarının kullanılmasından bahsedeceğim. Hazırsanız başlayalım! 🙂\ndocker \u0026lt;cmd\u0026gt; \u0026hellip; Öncelikle tüm docker komutları docker kelimesiyle başlıyor. Serinin sonraki bölümlerinde bahsedeceğim eklentiler ise docker- ön ekiyle (docker-compose, docker-swarm gibi..) başlıyorlar. Hiç bir parametre vermeden yalnızca bu komutları yazacak olursanız ilgili komuta ait yardım metinleri ekranınıza çıkacaktır. Dolayısıyla docker’ı ya da eklentilerini kurduktan sonra, kurulumunuzun başarılı olduğunu anlamak için ilk yapmanız gereken şey herhangi bir parametre vermeden çalıştırdığınızda yardım metinlerini görüp göremediğiniz olmalı.",
  "keywords": [
    "yazılım", "docker", "docker serisi", "container", "sanallaştırma", "linux", "devops"
  ],
  "articleBody": "Docker Serisi’nin ilk bölümünde sanallaştırmanın ne olduğundan, container teknolojisinden ve temel Docker kavramlarından bahsetmiştim. Serinin bu bölümünde temel Docker komutlarının kullanılmasından bahsedeceğim. Hazırsanız başlayalım! 🙂\ndocker … Öncelikle tüm docker komutları docker kelimesiyle başlıyor. Serinin sonraki bölümlerinde bahsedeceğim eklentiler ise docker- ön ekiyle (docker-compose, docker-swarm gibi..) başlıyorlar. Hiç bir parametre vermeden yalnızca bu komutları yazacak olursanız ilgili komuta ait yardım metinleri ekranınıza çıkacaktır. Dolayısıyla docker’ı ya da eklentilerini kurduktan sonra, kurulumunuzun başarılı olduğunu anlamak için ilk yapmanız gereken şey herhangi bir parametre vermeden çalıştırdığınızda yardım metinlerini görüp göremediğiniz olmalı.\nDocker komutları info, build, exec, ps, rm, run gibi kelimelerden oluşuyor ve bir üst paragrafta bahsettiğim yardım metinlerinde tam listesini görebilirsiniz. Bu komutların yardım metinlerine ise\ndocker help build ya da docker build -h ya da docker build --help\nyazarak ulaşabilirsiniz. Üçü de aynı çıktıyı verecektir. Her komutu kullanmadan önce başka neler yapabileceğinizi anlamak/öğrenmek için bu komutları yazarak denemeler yapmanız faydalı olacaktır. Serinin tüm yazılarında yalnızca sık kullanılan parametreleri anlatıyor olacağım.\nDevam etmeden önce docker kurulumunuzun başarılı olduğundan ve çalıştığından emin olmak için docker info komutunu verin:\ndocker info komutunu verdiğinizde buna benzer bir çıktı almalısınız\ndocker ps docker ps -a komut çıktısı\nDocker Engine üstünde bulunan container’ları listeleyen komut. Öntanımlı olarak kapalı ya da bir sebepten dolayı durmuş olan container’lar gösterilmez. Hepsini görebilmek için bu komuta -a ya da --all parametresini vermelisiniz. Şimdi gelin bu komuttaki kolonları adım adım inceleyelim:\nCONTAINER ID İlgili container’a atanmış benzersiz bir tanımlayıcı. Docker komutlarını kullanırken (örneğin silme işlemi için) container’a referans vermek için container adını kullanabileceğiniz gibi bu ID’yi de kullanabilirsiniz.\nIMAGE Container’ın hangi imajdan türediğini belirtir. :6.2-slim gibi belirteçler, o imajın sürüm numarasını belirtir. Sürüm numarası belirtilmemiş imajlar ise öntanımlı olarak :latest yani en güncel sürüm olarak kullanılmış demek oluyor.\nCOMMAND Bir önceki bölümde bahsettiğim gibi container’lar içlerinde tek bir süreç (process) çalıştırmak üzere tasarlanıyorlar. İlgili container’ı çalıştırmak için hangi komutun kullanıldığını bu bölümden görebilirsiniz. Terminal penceresine sığabilmesi için kısaltılmış formda gösterilen bu komutların tam halini görmek için --no-trunc parametresini (docker ps -a --no-trunc) kullanabilirsiniz.\nCREATED Container’ın yaratıldığı anı şimdiki zamanı baz alarak belirtir.\nSTATUS Container açıksa ne kadar süredir çalıştığını şimdiki zamanı baz alarak belirtir ya da eğer kapalıysa varsa çıkış koduyla birlikte yine şimdiki zamanı baz alarak kapanış zamanını belirtir.\nPORTS Container’ın açmak istediği erişim noktalarını (port) gösterir. Her yönlendirmedeki ilk kısım ev sahibi makinedeki (host), ikinci kısım ise container’ın içindeki erişim noktasını gösterir. Ekran görüntüsünde görüleceği üzere ilk container’da herhangi bir port yönlendirmesi bulunmuyor. İkincisinde ise ev sahibi makinenin tüm iletişim arabirimlerinden (interface) gelecek trafiğe açık olacak şekilde 32769 numaralı erişim noktasına, container’ın 80. erişim noktasına; 32768 numaralı erişim noktası ise container’ın 443. erişim noktasına yönlendirilmiş.\nNAMES Container’ın ismi. Container’la ilgili bir komut vereceğinizde bu isimle referans verebilirsiniz. İsim atanmayanlara Docker tarafından otomatik olarak rastgele bir isim atanır.\nEğer Mac ve Docker 1.11.x sürümünü kullanıyorsanız, Docker’ı Virtualbox ya da VMWare gibi bir hypervisor içinde kullanıyor olma ihtimaliniz yüksek. Virtualbox kullandığınızı varsayarsam, yukarıdaki erişim noktası yönlendirmesinde ev sahibi makine sizin makineniz değil, Virtualbox içinde çalışan makinedir. Bu durumda yukarıdaki örnekte çalışan nginx’e, makinenizin IP adresiyle değil, Virtualbox’ta açık olan sanal makinenin IP adresiyle (genelde 192.168.99.100) bağlanmalısınız.\nİpucu: Dilerseniz sanal makinenin IP adresini docker.local adıyla /etc/hosts dosyasına ekleyerek IP adresi girme zahmetinden kurtulabilirsiniz.\nHenüz Docker 1.12’yi yüklemediyseniz mutlaka yükleyin. Bu sayede macOS’un dahili sanallaştırma özelliklerinden faydalanıyor; dolayısıyla da daha verimli ve daha az güç tüketerek Docker ile çalışabiliyor olacaksınız. Bu sürümle birlikte gelen bir çok özellikten serinin bir sonraki yazısında bahsediyor olacağım. Bir üst paragraftan farklı olarak; 1.12 sürümünü yüklediğiniz takdirde, çalıştıracağınız tüm servisler doğrudan localhost ya da 127.0.0.1 üstünden erişilebilir olacaktır.\ndocker images docker images komut çıktısı\nDocker Engine içerisine indirilmiş (bknz: docker pull) imajların listesini döner. Bu imajlar Docker Hub’dan indirilmiş ya da ev sahibi makine üstünde oluşturulmuş (bknz: docker build) olabilir. Yeni başlattığınız container’ların imajları ve onların baz aldığı disk imajları burada listelenecektir. Container oluşturulurken ya da başlatılırken baz alınan bir imaj bu listede bulunmuyorsa öncelikle indirilecektir.\ndocker search tomcat Docker Hub’daki tomcat imajları arasında arama yapmanızı sağlar. Komut çıktısında imajın adını, tanımını, kaç yıldız aldığını (popülerliğini), resmi olup olmadığını ve son olarak otomatik derlenip derlenmediğini görebilirsiniz.\ndocker search tomcat komutunun çıktısı\nDocker Hub’a tüm kullanıcılar imaj atabildikleri için mümkün olduğunca resmi imajları kullanıyor olmanız önem taşıyor. Resmi olmayan imajlarda ise otomatik derlenenleri tercih etmeniz daha doğru olacaktır.\ndocker pull tomcat:8-jre8 Yeni bir container başlatabilmek için öncelikle o container’ın çalışacağı imaja sahip olmalısınız. Serinin bir önceki yazısındaki “İmaj ne demek?” bölümünde bahsettiğim gibi, bir disk imajı çeşitli katmanlardan oluşuyor ve imaj değiştikçe yeni katmanlar ekleniyor. Bu bilgiden yola çıkarak; yukarıdaki komut ile Tomcat 8.x’in Java 8 ile çalışan son sürümünü tüm katmanlarıyla indiriyoruz. Sondaki, : işaretinden sonraki kısım (8-jre8), indireceğimiz imajın sürüm kodunu ifade ediyor. Sürüm kodu olarak hiç bir şey yazmamış olsaydık (docker pull tomcat) öntanımlı olarak :latest yazdığımız varsayılacak ve tomcat’in son sürümü indirilecekti.\nDiyelim ki; indirdiğiniz zamandan bu yana Tomcat 8 Java 8’de bazı değişiklikler yapıldı. Bu komutu tekrar verdiğinizde, Docker yalnızca bilgisayarınızda mevcut olan katmandan sonraki katmanları indirerek işlemin çok daha hızlı gerçekleşmesini sağlayacaktır.\nDiyelim ki; Tomcat 8 Java 8’i baz alan başka bir imajı indireceksiniz. Bu durumda da Docker yalnızca bilgisayarınızda mevcut olan katmandan sonraki katmanları inderecektir.\ndocker build -t registry.gitlab.com/tunix/alperkan.at:1.0.5 . Yeni bir container imajı oluşturmak için bu komutu kullanabilirsiniz. Detaya inmeden belirteyim; bu komutun çalışabilmesi için projenin içinde en az bir adet Dockerfile bulunması gerekiyor. Dockerfile’la ilgili detayları bu bölümün ilerleyen kısımlarında bulabilirsiniz.\n-t parametresiyle oluşturduğunuz sürümü etiketlemiş oluyorsunuz. Yani bu durumda oluşturduğum imaj registry.gitlab.com/tunix/alperkan.at:1.0.5 adıyla etiketlenmiş olacak. Sondakinin sürüm numarası olduğunu daha önce belirtmiştim. Peki baştaki kısım neyin nesi?\nAslında sadece alperkan.at:1.0.5 şeklinde de oluşturabilirdim bu imajı. Ve daha sonrasında;\ndocker tag alperkan.at:1.0.5 registry.gitlab.com/tunix/alperkan.at:1.0.5 yapabilirdim. Baştan bu şekilde yapmamın ilk sebebi docker tag gibi ikinci bir komut vermemek. Bu şekilde etiketleme sebebim ise docker’da bir imajı bir depoya yollayabilmemin tek yolunun, imajın adını o depoyla etiketlemek olması. Bu durumda eğer GitLab Container Registry yerine örneğin Docker Hub kullanacak olsaydım imajımı docker.io/tunix/alperkan.at:1.0.5 olarak etiketlemem gerekecekti.\ndocker build komutu\ndocker build komutunun sonundaki nokta, imajın oluşturulacağı Dockerfile dosyasının yerini belirtir. Noktanın karşılığı Bash ve ZSH gibi genel geçer kabuklarda (shell) “bulunduğum dizin” demektir.\nYine Dockerfile’dan bahsettiğim bölümde anlatacağım ama şimdiden belirtmekte fayda var. Olur da herhangi bir sebepten dolayı parametrik imaj oluşturmanız gerekirse Dockerfile’da değişken tanımlamanız ve bu değişkenin değerini docker build komutu içerisinde --build-arg parametreleriyle verebileceğinizi belirteyim. Örneğin tek sayfalık web uygulamalarında (Single Page Application), uygulamanın bağlanacağı ortamı imajı oluştururken verip geliştirme ve test ortamına bağlanan 2 farklı imaj yaratabilirsiniz:\ndocker build -t example.com/web:1.0.0 \\ --build-arg SERVICE_URL=”http://dev.example.com” \\ --build-arg SERVICE_CONFIG=dev . docker push registry.gitlab.com/tunix/alperkan.at:1.0.5 Bilgisayarınızda oluşturduğunuz imajı uzaktaki depoya yüklemenizi sağlar. Eğer yükleyeceğiniz depo, giriş yapmanızı gerektiriyorsa, bu komuttan önce:\ndocker login registry.gitlab.com komutuyla giriş yapmanız gerekir. Bu komut, ev dizininizdeki .docker/config.json dosyasını yoksa oluşturacak ve giriş yapmanızı gerektiren komutlarda kullanmanız gereken ayırt edici şifreyi içine kullandığınız depo adresiyle birlikte yazacaktır.\nKullandığım örneklerde GitLab Container Registry kullandığım için registry.gitlab.com adresini kullanıyorum. Docker Hub ya da farklı bir depo ile çalışıyorsanız komutta değişiklik yapmalısınız.\ndocker push komutuyla bilgisayarınızdaki imaj için oluşturulan tüm katmanlar (baz alınan katmanlar depoda yüklüyse atlanarak) karşı taraftaki depoya yüklenecektir. Bu sayede imaja ihtiyaç duyan her yerde docker pull komutunu kullanarak imajı indirebilir ve bu imajdan container’lar oluşturabilirsiniz.\ndocker rmi registry.gitlab.com/tunix/alperkan.at:1.0.5 İmaj silmek için bu komutu kullanabilirsiniz. Silinecek imajda sürüm numarası bulunuyorsa özel olarak belirtmelisiniz. latest olarak etiketlenmiş bir imajı silmek için herhangi bir sürüm belirtmeniz gerekmez.\nBu arada imajın ID’sini biliyorsanız (bknz: docker images) doğrudan onu da kullanabilirsiniz:\ndocker rmi f24630ebe597 docker run … Bilgisayarınıza indirdiğiniz bir imajdan bir adet container çalıştırmanızı sağlar. Çalıştıracağınız yazılıma göre, docker run’a vereceğiniz parametreler de değişiklik gösterecektir. Gelin, bir kaç örnek üstünden ilerleyelim.\ndocker run -it --rm ubuntu /bin/bash Bu komutla, yukarıda bahsettiğim gibi; eğer makinenizde Ubuntu’nun son sürümü yoksa indirilecek ve interaktif modda (-it sayesinde) Bash kabuğu açılıp sizden komut yazmanızı bekleyecektir. Komut satırından çıkış yaptığınızda container otomatik olarak silinecektir. (--rm sayesinde) Peki ne işe yarar? Aklıma gelen bazı örnekler:\nMakinenize kurmak istemediğiniz ya da kurması zorlu olan yazılımlarla hızlı denemeler/testler yapabilirsiniz. Örneğin hızlı bir ownCloud denemesi yapabilir ya da elinizdeki veri setini MySQL’e hızlıca aktarıp üstünde işlemler yapıp çıktısını makinenize kaydedip container’ı uçurabilirsiniz. Başka bir işletim sisteminde çalışan bir yazılımı sanki yerel bir uygulamaymış gibi çalıştırabilirsiniz. (macOS’de olmayan komut satırı araçlarını çalıştırmak vb.) Örneğin Tomcat çalıştırdığınızı varsayarsak (docker run -it --rm tomcat /bin/bash) imaj içinde neyin nasıl yapıldığını/yerleştirildiğini inceleyebilir ve denemeler yapabilirsiniz. docker run -d --name deneme --restart=always -p 3000:3000 alperkan.at:1.0.5 Sırasıyla parametrelerin üstünden geçersek;\n-d: İnteraktif modun aksine container’ın arkaplanda çalışmasını sağlar. --name: Çalışan container’a istediğiniz bir ismin atanmasını, böylece kolaylıkla ulaşabilmenizi sağlar. --restart=always: Docker Engine’in ya da container’ın herhangi bir şekilde kapanması sonrasında otomatik olarak yeniden başlatılmasını sağlar. Diğer olası değerler: no, on-failure:5, unless-stopped -p 3000:3000: Ev sahibi makinedeki 3000. bağlantı noktasını, container içerisindeki 3000. porta yönlendirir. Alternatif olarak yalnızca -P yazmanız halinde container’ın açılması istenen tüm bağlantı noktaları, ev sahibi üstündeki rastgele bağlantı noktalarına yönlendirilir. Pro Tip: Özellikle ölçeklenebilirliğin önemli olduğu durumlarda -P kullanmak daha doğrudur.\nBu komutla beraber kullanılabilecek diğer bazı önemli parametreler ise şöyle:\n-e: Container içerisinde çevresel değişkenler tanımlamak için kullanılır. Bu sayede çalışma esnasında uygulamanın davranışını değiştirebilir, kritik parametreleri dışarıdan sağlayabilir ya da örneğin MySQL, Tomcat vb. uygulamaların yetkili kullanıcı adını veya şifresini dışarıdan tanımlayabilirsiniz. Tanımlamak istediğiniz her çevresel değişken için ayrı ayrı -e parametreleri tanımlayabilirsiniz. (ör: -e MYSQL_ROOT_PASSWORD=test) Container imajlarının değiştirilmezlik ilkesini göz önünde bulundurarak; çevresel değişkenlerin en önemli özelliklerden biri olduğunu vurgulamalıyım. Serinin ilerleyen bölümlerinde gerçek örneklerle nasıl kullanabileceğimizi göreceğiz.\n-v: Container içerisindeki bir dizin ya da dosyayı, ev sahibi makine üstündeki bir dizine bağlamak için kullanılır. Bağlamak istediğiniz her dizin ve dosya için ayrı ayrı -v parametresi tanımlayabilirsiniz. (ör: -v /home/alper/tomcat/webapps:/opt/tomcat/webapps) Unutulmaması gereken kısım; bu komutun kullanılması durumunda container’ın dışa bağımlı hale geliyor olması ve imajın değiştirilmezlik ilkesine aslında ters olduğu.\n-l: Container’a çeşitli etiketler atamanızı sağlar. (ör: -l TYPE=web -l PRIORITY=1) Tanımlamak istediğiniz her etiket için ayrı ayrı -l tanımı yapabilirsiniz. Özellikle ölçeklenebilirliğin önemli olduğu durumlarda Docker Engine’in kendisine ve container’lara etiketler atamak oldukça büyük önem arz ediyor.\n-u: Çalışacak container’ın hangi kullanıcıyla çalışacağını belirler. Öntanımlı olarak her container root yetkileriyle çalışıyor ve bu durum aslına bakarsanız güvenlik açıklarına sebebiyet verebiliyor. Bu nedenle container’ları mümkünse yetkisiz kullanıcılarla çalıştırmalısınız. Serinin ilerleyen bölümlerinde bahsedeceğim Dockerfile’lar sayesinde bu adımı çalıştırma esnasında parametre vermeksizin geçiştirebilirsiniz.\ndocker run komutuna bunların dışında verebileceğiniz daha pek çok parametre bulunuyor. Örneğin; çalıştıracağınız container’a ayrılacak CPU ve belleği belirtebileceğiniz gibi disk okuma/yazma hızını ya da hangi ağa erişeceğini ayarlayabilirsiniz. Tüm bu detayları bu yazının başında belirttiğim gibi; docker run --help komutuyla öğrenebilirsiniz.\ndocker logs –tail 20 -f alperkan.at Docker container’ları genellikle yalnızca tek bir süreç çalıştıracak ve temel çıktıya (stdout) bir şeyler basacak şekilde tasarlanırlar. Temel çıktıya basılan işlem kayıtlarına bu komutla ulaşabilirsiniz. Örneğin bir nginx container’ı başlatırsanız; access.log’u bu komutla takip edebilirsiniz.\n--tail: En son N satırdan itibaren çıktıyı ekrana getirir. -f: Komut iptal edilene kadar (Ctrl-C) çıktıyı takip etmeye devam eder.\ndocker exec -it alperkan.at ls -l /srv Çalışan (hali hazırda çalışmayan bir container’da bu komutu kullanamazsınız) bir container içinde komutlar çalıştırmanızı sağlayan bu komutu yalnızca container imajını hazırlarken ya da container’daki sorunları anlamaya çalışırken kullanmalısınız.\nBu komutu genellikle docker logs ile takip edemediğiniz farklı log dosyalarını takip etmek ya da kabuk başlatıp daha ileri seviye işler yapmak için kullanabilirsiniz. İhtiyacınız olabilecek örnek komutlar:\ndocker exec -it nginx-proxy tail -F /var/log/nginx/error.log docker exec -it alperkan.at /bin/bash docker cp ~/Desktop/data.json alperkan.at:/srv/data/me.json Bilgisayarınızdaki bir dosyayı/dizini container’a ya da container’daki bir dosyayı/dizini bilgisayarınıza kopyalamanızı sağlar.\n-L: Olası sembolik dosya ve dizinlerin de doğru şekilde kopyalanmasını garantiler.\ndocker stop alperkan.at Çalışan bir container’ı durdurmanızı sağlar. Bazen bir container’a daha sonra tekrar ihtiyacınız olabilir. Bu tip durumlarda durdurup sonra tekrar docker start komutuyla ayağa kaldırabilirsiniz.\n-t: Container kapanmakta gecikirse bu komutu vererek N saniye geçtikten sonra öldürülmesini sağlayabilirsiniz.\ndocker start alperkan.at docker stop komutuyla durdurduğunuz bir container’ı yeniden başlatmanızı sağlar.\n-a: Container’ı başlattıktan sonra temel çıktısının bulunduğunuz kabuk oturumuna bağlanmasını sağlar.\ndocker inspect alperkan.at Çalışan container’la ilgili çok detaylı bilgilere ulaşmanızı sağlar. Bu komutla örneğin; container’da çalışan çevresel değişkenlere, tanımlanmış bağlantı noktalarına, bağlanmış disk alanlarına ve daha pek çok bilgiye ulaşabilirsiniz.\nPro Tip: Bu komuta çıktısı içerisinde rahatça dolaşabilmek ve arama yapabilmek için |less eklemek isteyebilirsiniz.\nSerinin bu bölümünün de sonuna geldik. Bir sonraki bölüm olan Docker Engine Bölüm 2’de kalıcı veri depolama, çevresel değişkenler, bağlantı noktaları, Dockerfile, kendi imajınızı hazırlamak, Docker Hub \u0026 Registry ve son olarak kendi özel Docker Hub’ınıza nasıl sahip olabileceğinizden bahsedeceğim.\nGidişâta göre bu planda zaman zaman değişiklikler yapacak olsam da serinin tüm bölümlerinin planına şuradan ulaşabilirsiniz.\nKatkılarından dolayı Şamil Can’a teşekkürler! Serinin bir sonraki bölümünde görüşmek üzere! ✌️\n",
  "wordCount" : "2073",
  "inLanguage": "tr",
  "datePublished": "2016-09-26T00:00:00Z",
  "dateModified": "2021-04-25T00:40:03+03:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://alperkan.at/tr/2016/09/docker-serisi-2/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Alper Kanat",
    "logo": {
      "@type": "ImageObject",
      "url": "https://alperkan.at/favicon.ico"
    }
  }
}
</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://alperkan.at/tr/ accesskey=h title="Alper Kanat (Alt + H)">Alper Kanat</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://alperkan.at/ title=🇬🇧 aria-label=🇬🇧>En</a></li></ul></span></div><ul id=menu><li><a href=https://alperkan.at/tr/arsiv title=arşiv><span>arşiv</span></a></li><li><a href=https://alperkan.at/tr/tags title=etiketler><span>etiketler</span></a></li><li><a href=https://alperkan.at/tr/hakkimda title=hakkımda><span>hakkımda</span></a></li><li><a href=https://github.com/tunix/notebook title=notlarım><span>notlarım</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Docker Serisi #2 -- Docker Engine Bölüm 1</h1><div class=post-meta>September 26, 2016</div></header><div class=post-content><p>Docker Serisi’nin <a href=https://alperkan.at/tr/2016/07/docker-serisi-1/>ilk bölümünde</a> sanallaştırmanın ne olduğundan, container
teknolojisinden ve temel Docker kavramlarından bahsetmiştim. Serinin bu bölümünde temel Docker komutlarının
kullanılmasından bahsedeceğim. Hazırsanız başlayalım! 🙂</p><h3 id=docker-cmd->docker &lt;cmd> &mldr;<a hidden class=anchor aria-hidden=true href=#docker-cmd->#</a></h3><p>Öncelikle tüm docker komutları <strong>docker</strong> kelimesiyle başlıyor. Serinin sonraki bölümlerinde bahsedeceğim eklentiler
ise <strong>docker-</strong> ön ekiyle <em>(docker-compose, docker-swarm gibi..)</em> başlıyorlar. Hiç bir parametre vermeden yalnızca bu
komutları yazacak olursanız ilgili komuta ait yardım metinleri ekranınıza çıkacaktır. Dolayısıyla docker’ı ya da
eklentilerini kurduktan sonra, kurulumunuzun başarılı olduğunu anlamak için ilk yapmanız gereken şey herhangi bir
parametre vermeden çalıştırdığınızda yardım metinlerini görüp göremediğiniz olmalı.</p><p>Docker komutları <code>info</code>, <code>build</code>, <code>exec</code>, <code>ps</code>, <code>rm</code>, <code>run</code> gibi kelimelerden oluşuyor ve bir üst paragrafta
bahsettiğim yardım metinlerinde tam listesini görebilirsiniz. Bu komutların yardım metinlerine ise</p><blockquote><p><code>docker help build</code> ya da
<code>docker build -h</code> ya da
<code>docker build --help</code></p></blockquote><p>yazarak ulaşabilirsiniz. Üçü de aynı çıktıyı verecektir. Her komutu kullanmadan önce başka neler yapabileceğinizi
anlamak/öğrenmek için bu komutları yazarak denemeler yapmanız faydalı olacaktır. Serinin tüm yazılarında yalnızca sık
kullanılan parametreleri anlatıyor olacağım.</p><p>Devam etmeden önce docker kurulumunuzun başarılı olduğundan ve çalıştığından emin olmak için <code>docker info</code> komutunu
verin:</p><figure><img loading=lazy src=docker_info_ciktisi.png alt="docker info komutunu verdiğinizde buna benzer bir çıktı almalısınız"><figcaption><p><code>docker info</code> komutunu verdiğinizde buna benzer bir çıktı almalısınız</p></figcaption></figure><h3 id=docker-ps>docker ps<a hidden class=anchor aria-hidden=true href=#docker-ps>#</a></h3><figure><img loading=lazy src=docker_ps_a_ciktisi.png alt="docker ps -a komut çıktısı"><figcaption><p><code>docker ps -a</code> komut çıktısı</p></figcaption></figure><p>Docker Engine üstünde bulunan container’ları listeleyen komut. Öntanımlı olarak kapalı ya da bir sebepten dolayı
durmuş olan container’lar gösterilmez. Hepsini görebilmek için bu komuta <code>-a</code> ya da <code>--all</code> parametresini vermelisiniz.
Şimdi gelin bu komuttaki kolonları adım adım inceleyelim:</p><h4 id=container-id>CONTAINER ID<a hidden class=anchor aria-hidden=true href=#container-id>#</a></h4><p>İlgili container’a atanmış benzersiz bir tanımlayıcı. Docker komutlarını kullanırken (örneğin silme işlemi için)
container’a referans vermek için container adını kullanabileceğiniz gibi bu ID’yi de kullanabilirsiniz.</p><h4 id=image>IMAGE<a hidden class=anchor aria-hidden=true href=#image>#</a></h4><p>Container’ın hangi imajdan türediğini belirtir. <code>:6.2-slim</code> gibi belirteçler, o imajın sürüm numarasını belirtir.
Sürüm numarası belirtilmemiş imajlar ise öntanımlı olarak <code>:latest</code> yani en güncel sürüm olarak kullanılmış demek
oluyor.</p><h4 id=command>COMMAND<a hidden class=anchor aria-hidden=true href=#command>#</a></h4><p><a href=https://alperkan.at/tr/2016/07/docker-serisi-1/>Bir önceki bölümde</a> bahsettiğim gibi container’lar içlerinde tek bir süreç (process)
çalıştırmak üzere tasarlanıyorlar. İlgili container’ı çalıştırmak için hangi komutun kullanıldığını bu bölümden
görebilirsiniz. Terminal penceresine sığabilmesi için kısaltılmış formda gösterilen bu komutların tam halini görmek
için <code>--no-trunc</code> parametresini (<code>docker ps -a --no-trunc</code>) kullanabilirsiniz.</p><h4 id=created>CREATED<a hidden class=anchor aria-hidden=true href=#created>#</a></h4><p>Container’ın yaratıldığı anı şimdiki zamanı baz alarak belirtir.</p><h4 id=status>STATUS<a hidden class=anchor aria-hidden=true href=#status>#</a></h4><p>Container açıksa ne kadar süredir çalıştığını şimdiki zamanı baz alarak belirtir ya da eğer kapalıysa varsa çıkış
koduyla birlikte yine şimdiki zamanı baz alarak kapanış zamanını belirtir.</p><h4 id=ports>PORTS<a hidden class=anchor aria-hidden=true href=#ports>#</a></h4><p>Container’ın açmak istediği erişim noktalarını (port) gösterir. Her yönlendirmedeki ilk kısım ev sahibi makinedeki
(host), ikinci kısım ise container’ın içindeki erişim noktasını gösterir. Ekran görüntüsünde görüleceği üzere ilk
container’da herhangi bir port yönlendirmesi bulunmuyor. İkincisinde ise ev sahibi makinenin tüm iletişim
arabirimlerinden (interface) gelecek trafiğe açık olacak şekilde 32769 numaralı erişim noktasına, container’ın 80.
erişim noktasına; 32768 numaralı erişim noktası ise container’ın 443. erişim noktasına yönlendirilmiş.</p><h4 id=names>NAMES<a hidden class=anchor aria-hidden=true href=#names>#</a></h4><p>Container’ın ismi. Container’la ilgili bir komut vereceğinizde bu isimle referans verebilirsiniz. İsim atanmayanlara
Docker tarafından otomatik olarak rastgele bir isim atanır.</p><p>Eğer Mac ve Docker 1.11.x sürümünü kullanıyorsanız, Docker’ı Virtualbox ya da VMWare gibi bir hypervisor içinde
kullanıyor olma ihtimaliniz yüksek. Virtualbox kullandığınızı varsayarsam, yukarıdaki erişim noktası yönlendirmesinde
ev sahibi makine sizin makineniz değil, Virtualbox içinde çalışan makinedir. Bu durumda yukarıdaki örnekte çalışan
nginx’e, makinenizin IP adresiyle değil, Virtualbox’ta açık olan sanal makinenin IP adresiyle (genelde 192.168.99.100)
bağlanmalısınız.</p><blockquote><p>İpucu: Dilerseniz sanal makinenin IP adresini docker.local adıyla /etc/hosts dosyasına ekleyerek IP adresi girme
zahmetinden kurtulabilirsiniz.</p></blockquote><p>Henüz Docker 1.12&rsquo;yi yüklemediyseniz mutlaka yükleyin. Bu sayede macOS’un dahili sanallaştırma özelliklerinden
faydalanıyor; dolayısıyla da daha verimli ve daha az güç tüketerek Docker ile çalışabiliyor olacaksınız. Bu sürümle
birlikte gelen bir çok özellikten serinin bir sonraki yazısında bahsediyor olacağım. <strong>Bir üst paragraftan farklı
olarak; 1.12 sürümünü yüklediğiniz takdirde, çalıştıracağınız tüm servisler doğrudan localhost ya da 127.0.0.1
üstünden erişilebilir olacaktır.</strong></p><h3 id=docker-images>docker images<a hidden class=anchor aria-hidden=true href=#docker-images>#</a></h3><figure><img loading=lazy src=docker_images_ciktisi.png alt="docker images komut çıktısı"><figcaption><p><code>docker images</code> komut çıktısı</p></figcaption></figure><p>Docker Engine içerisine indirilmiş (bknz: <a href=#docker-pull-tomcat8-jre8>docker pull</a>) imajların listesini
döner. Bu imajlar Docker Hub’dan indirilmiş ya da ev sahibi makine üstünde oluşturulmuş
(bknz: <a href=#docker-build--t-registrygitlabcomtunixalperkanat105->docker build</a>) olabilir. Yeni
başlattığınız container’ların imajları ve onların baz aldığı disk imajları burada listelenecektir. Container
oluşturulurken ya da başlatılırken baz alınan bir imaj bu listede bulunmuyorsa öncelikle indirilecektir.</p><h3 id=docker-search-tomcat>docker search tomcat<a hidden class=anchor aria-hidden=true href=#docker-search-tomcat>#</a></h3><p><a href=https://hub.docker.com/>Docker Hub</a>’daki tomcat imajları arasında arama yapmanızı sağlar. Komut çıktısında imajın
adını, tanımını, kaç yıldız aldığını (popülerliğini), resmi olup olmadığını ve son olarak otomatik derlenip
derlenmediğini görebilirsiniz.</p><figure><img loading=lazy src=docker_search_tomcat_ciktisi.png alt="docker search tomcat komutunun çıktısı"><figcaption><p><code>docker search tomcat</code> komutunun çıktısı</p></figcaption></figure><p><a href=https://hub.docker.com/>Docker Hub</a>’a tüm kullanıcılar imaj atabildikleri için mümkün olduğunca resmi imajları
kullanıyor olmanız önem taşıyor. Resmi olmayan imajlarda ise otomatik derlenenleri tercih etmeniz daha doğru olacaktır.</p><h3 id=docker-pull-tomcat8-jre8>docker pull tomcat:8-jre8<a hidden class=anchor aria-hidden=true href=#docker-pull-tomcat8-jre8>#</a></h3><p>Yeni bir container başlatabilmek için öncelikle o container’ın çalışacağı imaja sahip olmalısınız. Serinin bir önceki
yazısındaki “<a href=https://alperkan.at/tr/2016/07/docker-serisi-1/#imaj-ne-demek>İmaj ne demek?</a>” bölümünde bahsettiğim gibi, bir disk imajı
çeşitli katmanlardan oluşuyor ve imaj değiştikçe yeni katmanlar ekleniyor. Bu bilgiden yola çıkarak; yukarıdaki komut
ile Tomcat 8.x’in Java 8 ile çalışan son sürümünü tüm katmanlarıyla indiriyoruz. Sondaki, : işaretinden sonraki kısım
(<code>8-jre8</code>), indireceğimiz imajın sürüm kodunu ifade ediyor. Sürüm kodu olarak hiç bir şey yazmamış olsaydık
(<code>docker pull tomcat</code>) öntanımlı olarak <code>:latest</code> yazdığımız varsayılacak ve tomcat’in son sürümü indirilecekti.</p><p>Diyelim ki; indirdiğiniz zamandan bu yana Tomcat 8 Java 8&rsquo;de bazı değişiklikler yapıldı. Bu komutu tekrar
verdiğinizde, Docker yalnızca bilgisayarınızda mevcut olan katmandan sonraki katmanları indirerek işlemin çok daha
hızlı gerçekleşmesini sağlayacaktır.</p><p>Diyelim ki; Tomcat 8 Java 8&rsquo;i baz alan başka bir imajı indireceksiniz. Bu durumda da Docker yalnızca bilgisayarınızda
mevcut olan katmandan sonraki katmanları inderecektir.</p><h3 id=docker-build--t-registrygitlabcomtunixalperkanat105->docker build -t registry.gitlab.com/tunix/alperkan.at:1.0.5 .<a hidden class=anchor aria-hidden=true href=#docker-build--t-registrygitlabcomtunixalperkanat105->#</a></h3><p>Yeni bir container imajı oluşturmak için bu komutu kullanabilirsiniz. Detaya inmeden belirteyim; bu komutun
çalışabilmesi için projenin içinde en az bir adet Dockerfile bulunması gerekiyor. Dockerfile’la ilgili detayları bu
bölümün ilerleyen kısımlarında bulabilirsiniz.</p><p><code>-t</code> parametresiyle oluşturduğunuz sürümü etiketlemiş oluyorsunuz. Yani bu durumda oluşturduğum imaj
<code>registry.gitlab.com/tunix/alperkan.at:1.0.5</code> adıyla etiketlenmiş olacak. Sondakinin sürüm numarası olduğunu daha önce
belirtmiştim. Peki baştaki kısım neyin nesi?</p><p>Aslında sadece <code>alperkan.at:1.0.5</code> şeklinde de oluşturabilirdim bu imajı. Ve daha sonrasında;</p><pre tabindex=0><code>docker tag alperkan.at:1.0.5 registry.gitlab.com/tunix/alperkan.at:1.0.5
</code></pre><p>yapabilirdim. Baştan bu şekilde yapmamın ilk sebebi docker tag gibi ikinci bir komut vermemek. Bu şekilde etiketleme
sebebim ise docker’da bir imajı bir depoya yollayabilmemin tek yolunun, imajın adını o depoyla etiketlemek olması. Bu
durumda eğer <a href=https://about.gitlab.com/2016/05/23/gitlab-container-registry/>GitLab Container Registry</a> yerine
örneğin <a href=https://hub.docker.com/>Docker Hub</a> kullanacak olsaydım imajımı <code>docker.io/tunix/alperkan.at:1.0.5</code> olarak
etiketlemem gerekecekti.</p><figure><img loading=lazy src=docker_build_komutunun_anatomisi.png alt="docker build komutu"><figcaption><p><code>docker build</code> komutu</p></figcaption></figure><p>docker build komutunun sonundaki nokta, imajın oluşturulacağı Dockerfile dosyasının yerini belirtir. Noktanın
karşılığı <a href=https://www.gnu.org/software/bash/>Bash</a> ve <a href=http://zsh.sourceforge.net/>ZSH</a> gibi genel geçer kabuklarda
(shell) “bulunduğum dizin” demektir.</p><p>Yine Dockerfile’dan bahsettiğim bölümde anlatacağım ama şimdiden belirtmekte fayda var. Olur da herhangi bir sebepten
dolayı parametrik imaj oluşturmanız gerekirse Dockerfile’da değişken tanımlamanız ve bu değişkenin değerini docker build
komutu içerisinde <code>--build-arg</code> parametreleriyle verebileceğinizi belirteyim. Örneğin tek sayfalık web uygulamalarında
(Single Page Application), uygulamanın bağlanacağı ortamı imajı oluştururken verip geliştirme ve test ortamına bağlanan
2 farklı imaj yaratabilirsiniz:</p><pre tabindex=0><code>docker build -t example.com/web:1.0.0 \
    --build-arg SERVICE_URL=”http://dev.example.com” \
    --build-arg SERVICE_CONFIG=dev .
</code></pre><h3 id=docker-push-registrygitlabcomtunixalperkanat105>docker push registry.gitlab.com/tunix/alperkan.at:1.0.5<a hidden class=anchor aria-hidden=true href=#docker-push-registrygitlabcomtunixalperkanat105>#</a></h3><p>Bilgisayarınızda oluşturduğunuz imajı uzaktaki depoya yüklemenizi sağlar. Eğer yükleyeceğiniz depo, giriş yapmanızı
gerektiriyorsa, bu komuttan önce:</p><pre tabindex=0><code>docker login registry.gitlab.com
</code></pre><p>komutuyla giriş yapmanız gerekir. Bu komut, ev dizininizdeki <code>.docker/config.json</code> dosyasını yoksa oluşturacak ve giriş
yapmanızı gerektiren komutlarda kullanmanız gereken ayırt edici şifreyi içine kullandığınız depo adresiyle birlikte
yazacaktır.</p><p>Kullandığım örneklerde <a href=https://about.gitlab.com/2016/05/23/gitlab-container-registry/>GitLab Container Registry</a>
kullandığım için <code>registry.gitlab.com</code> adresini kullanıyorum. <a href=https://hub.docker.com/>Docker Hub</a> ya da farklı bir
depo ile çalışıyorsanız komutta değişiklik yapmalısınız.</p><p><code>docker push</code> komutuyla bilgisayarınızdaki imaj için oluşturulan tüm katmanlar (baz alınan katmanlar depoda yüklüyse
atlanarak) karşı taraftaki depoya yüklenecektir. Bu sayede imaja ihtiyaç duyan her yerde <code>docker pull</code> komutunu
kullanarak imajı indirebilir ve bu imajdan container’lar oluşturabilirsiniz.</p><h3 id=docker-rmi-registrygitlabcomtunixalperkanat105>docker rmi registry.gitlab.com/tunix/alperkan.at:1.0.5<a hidden class=anchor aria-hidden=true href=#docker-rmi-registrygitlabcomtunixalperkanat105>#</a></h3><p>İmaj silmek için bu komutu kullanabilirsiniz. Silinecek imajda sürüm numarası bulunuyorsa özel olarak belirtmelisiniz.
<code>latest</code> olarak etiketlenmiş bir imajı silmek için herhangi bir sürüm belirtmeniz gerekmez.</p><p>Bu arada imajın ID’sini biliyorsanız (bknz: <a href=#docker-images>docker images</a>) doğrudan onu da
kullanabilirsiniz:</p><pre tabindex=0><code>docker rmi f24630ebe597
</code></pre><h3 id=docker-run->docker run &mldr;<a hidden class=anchor aria-hidden=true href=#docker-run->#</a></h3><p>Bilgisayarınıza indirdiğiniz bir imajdan bir adet container çalıştırmanızı sağlar. Çalıştıracağınız yazılıma göre,
<code>docker run</code>’a vereceğiniz parametreler de değişiklik gösterecektir. Gelin, bir kaç örnek üstünden ilerleyelim.</p><pre tabindex=0><code>docker run -it --rm ubuntu /bin/bash
</code></pre><p>Bu komutla, yukarıda <a href=#docker-pull-tomcat8-jre8>bahsettiğim</a> gibi; eğer makinenizde Ubuntu’nun son
sürümü yoksa indirilecek ve interaktif modda (<code>-it</code> sayesinde) Bash kabuğu açılıp sizden komut yazmanızı bekleyecektir.
Komut satırından çıkış yaptığınızda container otomatik olarak silinecektir. (<code>--rm</code> sayesinde) Peki ne işe yarar?
Aklıma gelen bazı örnekler:</p><ul><li>Makinenize kurmak istemediğiniz ya da kurması zorlu olan yazılımlarla hızlı denemeler/testler yapabilirsiniz.
<em>Örneğin hızlı bir ownCloud denemesi yapabilir ya da elinizdeki veri setini MySQL’e hızlıca aktarıp üstünde işlemler
yapıp çıktısını makinenize kaydedip container’ı uçurabilirsiniz.</em></li><li>Başka bir işletim sisteminde çalışan bir yazılımı sanki yerel bir uygulamaymış gibi çalıştırabilirsiniz.
(macOS’de olmayan komut satırı araçlarını çalıştırmak vb.)</li><li>Örneğin Tomcat çalıştırdığınızı varsayarsak (<code>docker run -it --rm tomcat /bin/bash</code>) imaj içinde neyin nasıl
yapıldığını/yerleştirildiğini inceleyebilir ve denemeler yapabilirsiniz.</li></ul><pre tabindex=0><code>docker run -d --name deneme --restart=always -p 3000:3000 alperkan.at:1.0.5
</code></pre><p>Sırasıyla parametrelerin üstünden geçersek;</p><ul><li><code>-d</code>: İnteraktif modun aksine container’ın arkaplanda çalışmasını sağlar.</li><li><code>--name</code>: Çalışan container’a istediğiniz bir ismin atanmasını, böylece kolaylıkla ulaşabilmenizi sağlar.</li><li><code>--restart=always</code>: Docker Engine’in ya da container’ın herhangi bir şekilde kapanması sonrasında otomatik olarak
yeniden başlatılmasını sağlar. Diğer olası değerler: <code>no</code>, <code>on-failure:5</code>, <code>unless-stopped</code></li><li><code>-p 3000:3000</code>: Ev sahibi makinedeki 3000. bağlantı noktasını, container içerisindeki 3000. porta yönlendirir.
<em>Alternatif olarak yalnızca -P yazmanız halinde container’ın açılması istenen tüm bağlantı noktaları, ev sahibi
üstündeki rastgele bağlantı noktalarına yönlendirilir.</em></li></ul><blockquote><p>Pro Tip: Özellikle ölçeklenebilirliğin önemli olduğu durumlarda -P kullanmak daha doğrudur.</p></blockquote><p>Bu komutla beraber kullanılabilecek diğer bazı önemli parametreler ise şöyle:</p><ul><li><p><code>-e</code>: Container içerisinde çevresel değişkenler tanımlamak için kullanılır. Bu sayede çalışma esnasında uygulamanın
davranışını değiştirebilir, kritik parametreleri dışarıdan sağlayabilir ya da örneğin MySQL, Tomcat vb.
uygulamaların yetkili kullanıcı adını veya şifresini dışarıdan tanımlayabilirsiniz. Tanımlamak istediğiniz her
çevresel değişken için ayrı ayrı -e parametreleri tanımlayabilirsiniz. (ör: <code>-e MYSQL_ROOT_PASSWORD=test</code>)
<strong>Container imajlarının değiştirilmezlik ilkesini göz önünde bulundurarak; çevresel değişkenlerin en önemli
özelliklerden biri olduğunu vurgulamalıyım.</strong> Serinin ilerleyen bölümlerinde gerçek örneklerle nasıl
kullanabileceğimizi göreceğiz.</p></li><li><p><code>-v</code>: Container içerisindeki bir dizin ya da dosyayı, ev sahibi makine üstündeki bir dizine bağlamak için kullanılır.
Bağlamak istediğiniz her dizin ve dosya için ayrı ayrı -v parametresi tanımlayabilirsiniz.
(ör: <code>-v /home/alper/tomcat/webapps:/opt/tomcat/webapps</code>) <strong>Unutulmaması gereken kısım; bu komutun kullanılması
durumunda container’ın dışa bağımlı hale geliyor olması ve imajın değiştirilmezlik ilkesine aslında ters olduğu.</strong></p></li><li><p><code>-l</code>: Container’a çeşitli etiketler atamanızı sağlar. (ör: <code>-l TYPE=web -l PRIORITY=1</code>) Tanımlamak istediğiniz her
etiket için ayrı ayrı -l tanımı yapabilirsiniz. Özellikle ölçeklenebilirliğin önemli olduğu durumlarda Docker
Engine’in kendisine ve container’lara etiketler atamak oldukça büyük önem arz ediyor.</p></li><li><p><code>-u</code>: Çalışacak container’ın hangi kullanıcıyla çalışacağını belirler. Öntanımlı olarak her container root
yetkileriyle çalışıyor ve bu durum aslına bakarsanız güvenlik açıklarına sebebiyet verebiliyor. Bu nedenle
container’ları mümkünse yetkisiz kullanıcılarla çalıştırmalısınız. <em>Serinin ilerleyen bölümlerinde bahsedeceğim
Dockerfile’lar sayesinde bu adımı çalıştırma esnasında parametre vermeksizin geçiştirebilirsiniz.</em></p></li></ul><p>docker run komutuna bunların dışında verebileceğiniz daha pek çok parametre bulunuyor. Örneğin; çalıştıracağınız
container’a ayrılacak CPU ve belleği belirtebileceğiniz gibi disk okuma/yazma hızını ya da hangi ağa erişeceğini
ayarlayabilirsiniz. Tüm bu detayları bu <a href=#docker-cmd->yazının başında belirttiğim</a> gibi;
<code>docker run --help</code> komutuyla öğrenebilirsiniz.</p><h3 id=docker-logs---tail-20--f-alperkanat>docker logs &ndash;tail 20 -f alperkan.at<a hidden class=anchor aria-hidden=true href=#docker-logs---tail-20--f-alperkanat>#</a></h3><p>Docker container’ları genellikle yalnızca tek bir süreç çalıştıracak ve temel çıktıya (stdout) bir şeyler basacak
şekilde tasarlanırlar. Temel çıktıya basılan işlem kayıtlarına bu komutla ulaşabilirsiniz. Örneğin bir nginx
container’ı başlatırsanız; <code>access.log</code>’u bu komutla takip edebilirsiniz.</p><p><code>--tail</code>: En son N satırdan itibaren çıktıyı ekrana getirir.
<code>-f</code>: Komut iptal edilene kadar (Ctrl-C) çıktıyı takip etmeye devam eder.</p><h3 id=docker-exec--it-alperkanat-ls--l-srv>docker exec -it alperkan.at ls -l /srv<a hidden class=anchor aria-hidden=true href=#docker-exec--it-alperkanat-ls--l-srv>#</a></h3><p>Çalışan (hali hazırda çalışmayan bir container’da bu komutu kullanamazsınız) bir container içinde komutlar
çalıştırmanızı sağlayan bu komutu yalnızca container imajını hazırlarken ya da container’daki sorunları anlamaya
çalışırken kullanmalısınız.</p><p>Bu komutu genellikle docker logs ile takip edemediğiniz farklı log dosyalarını takip etmek ya da kabuk başlatıp daha
ileri seviye işler yapmak için kullanabilirsiniz. İhtiyacınız olabilecek örnek komutlar:</p><pre tabindex=0><code>docker exec -it nginx-proxy tail -F /var/log/nginx/error.log
docker exec -it alperkan.at /bin/bash
</code></pre><h3 id=docker-cp-desktopdatajson-alperkanatsrvdatamejson>docker cp ~/Desktop/data.json alperkan.at:/srv/data/me.json<a hidden class=anchor aria-hidden=true href=#docker-cp-desktopdatajson-alperkanatsrvdatamejson>#</a></h3><p>Bilgisayarınızdaki bir dosyayı/dizini container’a ya da container’daki bir dosyayı/dizini bilgisayarınıza
kopyalamanızı sağlar.</p><p><code>-L</code>: Olası sembolik dosya ve dizinlerin de doğru şekilde kopyalanmasını garantiler.</p><h3 id=docker-stop-alperkanat>docker stop alperkan.at<a hidden class=anchor aria-hidden=true href=#docker-stop-alperkanat>#</a></h3><p>Çalışan bir container’ı durdurmanızı sağlar. Bazen bir container’a daha sonra tekrar ihtiyacınız olabilir. Bu tip
durumlarda durdurup sonra tekrar <a href=#docker-start-alperkanat>docker start</a> komutuyla ayağa
kaldırabilirsiniz.</p><p><code>-t</code>: Container kapanmakta gecikirse bu komutu vererek N saniye geçtikten sonra öldürülmesini sağlayabilirsiniz.</p><h3 id=docker-start-alperkanat>docker start alperkan.at<a hidden class=anchor aria-hidden=true href=#docker-start-alperkanat>#</a></h3><p><a href=#docker-stop-alperkanat>docker stop</a> komutuyla durdurduğunuz bir container’ı yeniden başlatmanızı
sağlar.</p><p><code>-a</code>: Container’ı başlattıktan sonra temel çıktısının bulunduğunuz kabuk oturumuna bağlanmasını sağlar.</p><h3 id=docker-inspect-alperkanat>docker inspect alperkan.at<a hidden class=anchor aria-hidden=true href=#docker-inspect-alperkanat>#</a></h3><p>Çalışan container’la ilgili çok detaylı bilgilere ulaşmanızı sağlar. Bu komutla örneğin; container’da çalışan çevresel
değişkenlere, tanımlanmış bağlantı noktalarına, bağlanmış disk alanlarına ve daha pek çok bilgiye ulaşabilirsiniz.</p><blockquote><p>Pro Tip: Bu komuta çıktısı içerisinde rahatça dolaşabilmek ve arama yapabilmek için <code>|less</code> eklemek isteyebilirsiniz.</p></blockquote><hr><p>Serinin bu bölümünün de sonuna geldik. Bir sonraki bölüm olan Docker Engine Bölüm 2&rsquo;de kalıcı veri depolama, çevresel
değişkenler, bağlantı noktaları, Dockerfile, kendi imajınızı hazırlamak, Docker Hub & Registry ve son olarak kendi
özel Docker Hub’ınıza nasıl sahip olabileceğinizden bahsedeceğim.</p><p>Gidişâta göre bu planda zaman zaman değişiklikler yapacak olsam da serinin tüm bölümlerinin planına
<a href=https://www.evernote.com/l/AB7CctYtJkpMUJsae1_3FgzIXgMY5MvFQhU>şuradan</a> ulaşabilirsiniz.</p><p>Katkılarından dolayı Şamil Can’a teşekkürler! Serinin bir sonraki bölümünde görüşmek üzere! ✌️</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://alperkan.at/tr/tags/yaz%C4%B1l%C4%B1m/>yazılım</a></li><li><a href=https://alperkan.at/tr/tags/docker/>docker</a></li><li><a href=https://alperkan.at/tr/tags/docker-serisi/>docker serisi</a></li><li><a href=https://alperkan.at/tr/tags/container/>container</a></li><li><a href=https://alperkan.at/tr/tags/sanalla%C5%9Ft%C4%B1rma/>sanallaştırma</a></li><li><a href=https://alperkan.at/tr/tags/linux/>linux</a></li><li><a href=https://alperkan.at/tr/tags/devops/>devops</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://alperkan.at/tr/>Alper Kanat</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById("menu");menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>